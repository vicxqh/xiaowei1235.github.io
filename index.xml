<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>萧七海的博客</title>
    <link>http://auntlei.com/</link>
    <description>Recent content on 萧七海的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Fri, 05 Feb 2021 16:16:27 +0800</lastBuildDate>
    
        <atom:link href="http://auntlei.com/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>About</title>
      <link>http://auntlei.com/about/</link>
      <pubDate>Sun, 20 Aug 2017 21:38:52 +0800</pubDate>
      
      <guid>http://auntlei.com/about/</guid>
      
        <description>&lt;p&gt;Hugo is a static site engine written in Go.&lt;/p&gt;
&lt;p&gt;It makes use of a variety of open source projects including:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/spf13/cobra&#34;&gt;Cobra&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/spf13/viper&#34;&gt;Viper&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/spf13/jWalterWeatherman&#34;&gt;J Walter Weatherman&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/spf13/cast&#34;&gt;Cast&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Learn more and contribute on &lt;a href=&#34;https://github.com/gohugoio&#34;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>用Golang实现内网穿透代理</title>
      <link>http://auntlei.com/post/net/srp/</link>
      <pubDate>Fri, 05 Feb 2021 16:16:27 +0800</pubDate>
      
      <guid>http://auntlei.com/post/net/srp/</guid>
      
        <description>&lt;h2 id=&#34;heading&#34;&gt;动机&lt;/h2&gt;
&lt;p&gt;想在家里搞个NAS，但是暂时没有充足的资金。正好家里有个闲置老旧笔记本，打算重装Linux之后，用来挂PT下载影视资源给电视串流，当成NAS使用。但是位于内外的服务器总归不够方便，需要内网穿透。虽然市场上已经有相对成熟的内网穿透工具，比如frp。但是配置frp的时候遇到了些问题，正好空闲，计划用自己写一个内网穿透工具。&lt;/p&gt;
&lt;h2 id=&#34;heading-1&#34;&gt;术语&lt;/h2&gt;
&lt;p&gt;服务端：本系统中在运行在具有公网IP的机器上的软件。&lt;/p&gt;
&lt;p&gt;客户端：本系统中运行在需要被暴露的内网环境中的软件，通常位于NAT设备之后。&lt;/p&gt;
&lt;p&gt;用户：系统之外，访问系统服务端绑定的某一端口的任何软件。&lt;/p&gt;
&lt;p&gt;内网服务：通过客户端被服务端暴露之后可被用户访问的软件。&lt;/p&gt;
&lt;h2 id=&#34;heading-2&#34;&gt;功能描述&lt;/h2&gt;
&lt;h3 id=&#34;heading-3&#34;&gt;目标&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;跨平台，客户端、服务端需要能运行在主流操作系统中，包括Mac/Linux/Windows&lt;/li&gt;
&lt;li&gt;能在公网机器上转发任意TCP流量到任意内网服务&lt;/li&gt;
&lt;li&gt;对于任一内网服务，需要支持多个并发用户访问&lt;/li&gt;
&lt;li&gt;可以同时暴露多个内网服务&lt;/li&gt;
&lt;li&gt;客户端具备自动重连功能&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;heading-4&#34;&gt;暂时不考虑/后期可增加的功能&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;GUI&lt;/li&gt;
&lt;li&gt;其它协议的支持，如果UDP，或者针对更上层协议（如HTTP）的特殊优化（更易于使用）&lt;/li&gt;
&lt;li&gt;多个相同内网服务间的负载均衡&lt;/li&gt;
&lt;li&gt;通信 鉴权、加密&lt;/li&gt;
&lt;li&gt;(可能的)性能优化&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;heading-5&#34;&gt;系统设计&lt;/h2&gt;
&lt;p&gt;系统的工作原理很简单。服务端会绑定很多端口，每个端口会映射到不同的被暴露的内网服务。用户通过请求特定的端口来请求特定的被暴露的内网服务。服务端在接受用户的请求之后，通过服务端-客户端之间的通道，将流量转发给内网服务，并且回复内网服务的回包。&lt;/p&gt;
&lt;p&gt;这其中最关键的部分就是如何构建一个转发通道。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://xiaoqihai.oss-cn-shanghai.aliyuncs.com/img/20210208152705.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;----&#34;&gt;通信协议 &amp;ndash; 转发通道设计&lt;/h3&gt;
&lt;p&gt;为了对来自不同用户的流量进行隔离，一个简单直观的方案就是为来自每个用户的链接，都创建一个到客户端的链接，客户端再创建一个到内网服务的链接，如下图所示。但问题在于位于公网的服务端没有办法主动与位于内网的客户端建立链接。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://xiaoqihai.oss-cn-shanghai.aliyuncs.com/img/20210207162216.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;既然链接只能从客户端发起，那么我们怎么才能实现转发不同用户流量呢？我这里想到有两种方案。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方案一 链接复用，客户端服务端之间封装私有7层协议&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://xiaoqihai.oss-cn-shanghai.aliyuncs.com/img/20210207164005.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;服务端启动之后，客户端请求服务端建立链接。此链接用于转发该机器上暴露的所有内网服务流量。客户端与服务端通过为数据包打上自定义的协议头，来区分不同用户不同服务之间的流量。&lt;/p&gt;
&lt;p&gt;自定义协议最少需要包含三部分信息：用户ID、内网服务ID。因为我们转发的是TCP协议，因此每个ID都可以使用对端链接的IP+Port来识别。用户ID+内网服务ID能唯一地确定一个用户和服务的会话。如下图定义的协议头中，我们引入了16字节的overhead。需要注意的是，其中的用户IP、Port可能是NAT设备的地址，但是这并不影响协议工作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://xiaoqihai.oss-cn-shanghai.aliyuncs.com/img/20210210113402.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方案二 服务端控制客户端主动建立链接，每个用户的请求一个单独的物理通道&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;虽然服务端不可以主动和客户端建立连接，但是在客户端与服务端建立初次链接之后（控制流链接），服务端可以向客户端发送控制指令，协调客户端向服务端建立链接。**这种方案要解决的关键问题是怎么让服务端知道新建链接中哪一条是客户端在控制指令之下创建的。**虽然TCP链接包含了本地端口和远端端口信息。但是因为客户端位于NAT网络之后，通过告诉服务端自己的本地端口号并不能让服务端从一众新建连接中找到这条特殊的链接。既然从TCP协议层信息中无法取出足够的信息，那么我们只能通过更上层的方法来识别。&lt;/p&gt;
&lt;p&gt;一个简单的方案&lt;/p&gt;
&lt;p&gt;客户端：在被控制建立链接之后，会向服务端发送一个握手包，这个握手包包含了一个随机生成的ID来表示链接名字。&lt;/p&gt;
&lt;p&gt;服务端：转发任何一个链接的流量时，&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;判断此链接是否是首次发送数据&lt;/li&gt;
&lt;li&gt;如果1成立，则进一步判断是否是自定义握手包。&lt;/li&gt;
&lt;li&gt;如果2成立，解析握手包中的ID，服务端记录此链接的ID，并通过此链接发送握手确认包。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;当客户端收到握手确认包之后，知道服务端已经建立好新建链接的映射，这时返回控制信息告诉服务端，已经按照要求建立链接，并附带链接ID。&lt;/p&gt;
&lt;p&gt;之后，用户、服务端、客户端、内网服务之间就可以通过新建立的物理通道进行流量的转发。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://xiaoqihai.oss-cn-shanghai.aliyuncs.com/img/20210208150919.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方案对比&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;方案一虽然节省了文件句柄资源，但是需要为每个业务流量都增加额外的自定义协议头会增加带宽消耗。方案二虽然每个来自用户的链接都有一条私有的“通道”，但是在能传输数据之前，相对方案一需要增加在服务端和客户端新建链接的延迟，首帧延迟更高。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;文件句柄消耗&lt;/th&gt;
&lt;th&gt;带宽消耗&lt;/th&gt;
&lt;th&gt;首帧延迟&lt;/th&gt;
&lt;th&gt;延迟&lt;/th&gt;
&lt;th&gt;实现复杂度&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;方案一&lt;/td&gt;
&lt;td&gt;少&lt;/td&gt;
&lt;td&gt;多&lt;/td&gt;
&lt;td&gt;低&lt;/td&gt;
&lt;td&gt;高&lt;/td&gt;
&lt;td&gt;低&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;方案二&lt;/td&gt;
&lt;td&gt;多&lt;/td&gt;
&lt;td&gt;少&lt;/td&gt;
&lt;td&gt;高&lt;/td&gt;
&lt;td&gt;低&lt;/td&gt;
&lt;td&gt;高&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;上面表格只是粗略进行了分析，针对我们自己家的场景和兴趣，最终&lt;strong&gt;选择了方案一&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;heading-6&#34;&gt;详细设计&lt;/h3&gt;
&lt;h4 id=&#34;heading-7&#34;&gt;技术选型&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;golang， 跨平台的兼容性和开发效率。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;heading-8&#34;&gt;服务端设计&lt;/h4&gt;
&lt;p&gt;和别的内网穿透软件客户端可以指定服务端为某个内网服务暴露的端口不一样的是，本文系统中服务端的端口都由服务端掌握。我觉得这是一种更合理的设计，因为服务端端口是服务端的资源，不应该由别的模块来配置。客户端只应该向服务端告知其有哪些服务可以暴露，至于是否暴露、以及怎么暴露应该有服务端决策。为了方便使用，服务端提供了REST接口对各种资源就行查阅、配置。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://xiaoqihai.oss-cn-shanghai.aliyuncs.com/img/20210208182502.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;服务端可以分为三个模块：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;HTTP Restful 接口
&lt;ul&gt;
&lt;li&gt;查看已经建立链接的客户端&lt;/li&gt;
&lt;li&gt;查看/新增/禁用/删除 客户端暴露的服务&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;链接管理， 管理客户端链接信息&lt;/li&gt;
&lt;li&gt;服务仓库， 记录所有内网服务的信息&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;http-restful-&#34;&gt;HTTP restful 接口&lt;/h5&gt;
&lt;p&gt;描述接口前，需要先定义两个关键数据结构：数据连接和内网服务。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// ClientConnection represents a client connection that is used for forwarding data between a client and a server.
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ClientConnection&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;ID&lt;/span&gt;          &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// unique
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;Description&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// Service represents a intranet service exposed on a server.
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Service&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;ID&lt;/span&gt;          &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// unique
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;Addr&lt;/span&gt;        &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;Description&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;ExposedBy&lt;/span&gt;   &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// ClientConnection.ID
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;ServerPort&lt;/span&gt;  &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// which server port exposes this service
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;c1&#34;&gt;// Enabled     bool   // access to users enabled?
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;​	HTTP 接口&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;GET /api/v1/dataport&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;返回数据管道监听的端口。客户端以此端口与服务端建立转发通道链接&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;GET /api/v1/services&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;返回所有的服务信息。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;GET /api/v1/services/:id&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;返回指定服务的信息&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;POST /api/v1/services&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;创建新服务&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;PUT /api/v1/services/:id&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;更新指定服务状态&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;DELETE /api/v1/services/:id&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;删除指定服务&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;PUT /api/v1/services/:id/exposure&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;修改服务暴露方式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;DELETE /api/v1/services/:id/expoure&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;删除服务当前的暴露&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;heading-9&#34;&gt;链接管理&lt;/h5&gt;
&lt;p&gt;服务端除了会监听一个端口用于处理HTTP请求之外，还会监听另外一个用于转发数据的端口。客户端和服务端建立转发通道的流程如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;访问接口&lt;code&gt;GET /api/v1/dataport&lt;/code&gt;获得数据接口端口号&lt;/li&gt;
&lt;li&gt;与服务端的数据接口建立TCP链接&lt;/li&gt;
&lt;li&gt;向服务端发送链接注册信息&lt;/li&gt;
&lt;li&gt;服务端接受到注册信息之后，判断ID是否重复
&lt;ol&gt;
&lt;li&gt;如果不重复，则回复信息确认，并在服务端注册此链接&lt;/li&gt;
&lt;li&gt;如果重复，则回复错误信息，并断开连接。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;链接注册信息和服务端确认信息结构体如下，暂定使用json序列化：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ConnectionRegistrationRequest&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ClientConnection&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ConnectionRegistrationResponse&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;Succeeded&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;bool&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;Message&lt;/span&gt;   &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h5 id=&#34;heading-10&#34;&gt;服务仓库&lt;/h5&gt;
&lt;p&gt;通过HTTP接口，可以向服务端注册内网服务，在收到注册请求之后，服务端会分配一个暴露的端口，用户可以通过访问此端口来房网内网服务&lt;/p&gt;
&lt;h4 id=&#34;heading-11&#34;&gt;客户端设计&lt;/h4&gt;
&lt;h2 id=&#34;heading-12&#34;&gt;附&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://restfulapi.net/resource-naming/&#34;&gt;REST API 命名规范&lt;/a&gt;&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>《高性能MySQL》读书笔记</title>
      <link>http://auntlei.com/post/reading/highperfmysql/</link>
      <pubDate>Tue, 26 Jan 2021 10:44:14 +0800</pubDate>
      
      <guid>http://auntlei.com/post/reading/highperfmysql/</guid>
      
        <description>&lt;h2 id=&#34;1-&#34;&gt;第1章 架构与历史&lt;/h2&gt;
&lt;h3 id=&#34;mysql-&#34;&gt;MySQL 逻辑架构&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://xiaoqihai.oss-cn-shanghai.aliyuncs.com/img/20210126110213.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;从上到下，可以分为三层。最上层就是普通的客户端；中间一层包含了MySQL的核心逻辑，包含接入授权、查询解析优化等；最下层则是各种存储引擎。&lt;/p&gt;
&lt;h3 id=&#34;heading&#34;&gt;并发控制&lt;/h3&gt;
&lt;p&gt;下面提到的锁都是读写锁&lt;/p&gt;
&lt;p&gt;锁粒度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;表锁 (table lock)，对整个表加锁&lt;/li&gt;
&lt;li&gt;行级锁 (row lock)，对指定行加锁&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;heading-1&#34;&gt;事务&lt;/h3&gt;
&lt;p&gt;事务的四个特性ACID。其中Isolation，隔离性在实践中可以分为四个隔离级别。&lt;/p&gt;
&lt;h4 id=&#34;heading-2&#34;&gt;隔离级别&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;READ UNCOMMITTED&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;读未提交，事务中的修改，即使没有提交，对其它事务也都是可见的。“脏读”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;READ COMMITTED&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;只能读已提交的修改。这个级别能解决脏读问题，但是却有新的问题，“不可重复读”——多次执行相同的查询语句时，因为有可能有别的事务提交修改，因此可能会读到不同的结果。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;REPEATABLE READ&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;对于一条数据，多次读取返回的值不会变。但是这个有引入了“幻读”的问题，虽然每一行的值确定不变，但是满足查询条件的行数发生了变化。比如查询一个范围内的记录，虽然对于每行记录每次读取都是一致的，但是因为别的事务可能插入新的记录，导致同样的范围查询返回更多的记录。但是，InnoDB 的MVCC能力解决了“幻读”的问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SERIALIZABLE&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;串行化。通过强制将事务的执行顺序串行化来解决幻读的问题。显而易见，这种方式的性能最差。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://xiaoqihai.oss-cn-shanghai.aliyuncs.com/img/20210126164519.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;mysql--1&#34;&gt;MySQL 中的事务&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;自动提交&lt;/strong&gt; MySQL默认采用自动提交的模式，即除非你显式的开启一个事务，否则每个查询语句都运行在一个独立的事务中。&lt;/p&gt;
&lt;p&gt;自动提交模式可以关闭&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;显式锁定与隐式锁定&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;InnoDB 使用“两阶段锁”模式，能在事务执行的任意时间点根据隔离级别的不同自动的获取锁，并且只在事务提交/回滚 之后才释放。&lt;/p&gt;
&lt;p&gt;也可以使用非标准的SQL语句显式地获得锁。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span class=&#34;k&#34;&gt;SELECT&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;LOCK&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;IN&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;SHARE&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;MODE&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;SELECT&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;FOR&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;UPDATE&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;mvcc&#34;&gt;多版本并发控制（MVCC）&lt;/h3&gt;
&lt;p&gt;虽然行级锁相对表锁有了很大的性能提升，但仍有提升空间。MVCC通过保存数据在某个时间点的快照，解决了幻读问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;InnoDB实现原理&lt;/strong&gt;，为每行数据额外增加了两列“最后修改时间”和“删除时间”，其中时间实际上是递增的事务版本号。每个事务只能看到自己的修改，以及在此之前的数据。&lt;/p&gt;
&lt;p&gt;MVCC只在REPEATABLE READ 和READ COMMITTED两个隔离级别下工作。其它两个隔离级别和MVCC不兼容。MVCC本质是限制读取的数据版本 &amp;lt;= 当前事务版本号，而READ UNCOMMITTED总是读取最新版本，因此不兼容。而SERIALIZABLE则总是在读取每一行数据时都加锁，因此也不兼容。&lt;/p&gt;
&lt;h3 id=&#34;mysql&#34;&gt;MySQL的存储引擎&lt;/h3&gt;
&lt;p&gt;MySQL使用文件系统的目录和文件来保存数据库和表的定义。创建表时，&lt;!-- raw HTML omitted --&gt;MySQL会在数据库子目录下创建一个和表同名的&lt;code&gt;.frm&lt;/code&gt;文件保存表的定义&lt;!-- raw HTML omitted --&gt;， &lt;em&gt;最新的MySQL 8.0我没找到这个文件，不过一个数据库是一个目录&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;除非有特殊考虑，默认使用InnoDB引擎&lt;/strong&gt;。InnoDB引擎支持事务（MVCC）和行级锁，对绝大多数影长场景而言，是性能和考虑性综合的最佳选择。&lt;/p&gt;
&lt;h2 id=&#34;2-mysql&#34;&gt;第2章 MySQL基准测试&lt;/h2&gt;
&lt;p&gt;就是在“基准”环境（测试集+特定硬件）下的压力测试。可以参考一些在线的数据，https://www.mysql.com/why-mysql/benchmarks/mysql/&lt;/p&gt;
&lt;h2 id=&#34;3-&#34;&gt;第3章 服务器性能剖析&lt;/h2&gt;
&lt;p&gt;略&lt;/p&gt;
&lt;h2 id=&#34;4-schema&#34;&gt;第4章 Schema与数据类型优化&lt;/h2&gt;
&lt;h3 id=&#34;heading-3&#34;&gt;选择优化的数据类型&lt;/h3&gt;
&lt;p&gt;三个简单原则&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;尽量使用最小的数据结构。当然前提是此结构能满足存储值的范围&lt;/li&gt;
&lt;li&gt;尽量使用简单数据结构。比如，整型比字符串操作代价更低。&lt;/li&gt;
&lt;li&gt;尽量避免NULL。尤其是在要给列建索引的时候。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;heading-4&#34;&gt;整型&lt;/h4&gt;
&lt;p&gt;有TINYINT， SMALLINT，MEDIUMINT，INT，BIGINT，分别使用8， 16， 24，32，64位存储空间。&lt;/p&gt;
&lt;p&gt;虽然MySQL可以为INT指定宽度，如INT(11），但它并不会限制合法范围，只是方便交互工具展示。&lt;/p&gt;
&lt;h4 id=&#34;heading-5&#34;&gt;实数类型&lt;/h4&gt;
&lt;p&gt;分精确类型（DECIMAL）和不精确类型（浮点数，FLOAT和DOUBLE）。DECIMAL可以存储比BIGINT还要大的整数。&lt;/p&gt;
&lt;h4 id=&#34;heading-6&#34;&gt;字符串&lt;/h4&gt;
&lt;p&gt;VARCHAR vs CHAR&lt;/p&gt;
&lt;p&gt;不同的引擎有不同的存储方式，下面的讨论是假设在InnoDB/MyISAM上。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;VARCHAR&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;存储变长字符串，相对定长字符串，更省空间，因此（读）性能也可能更好。但是UPDATE操作可能产生碎片，或者要求更大的存储空间，而导致（更新）新能降低。&lt;/li&gt;
&lt;li&gt;适合最大长度明显大于平均长度的场景&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;CHAR&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;定长字符串。所有的值都是一个长度，或者接近一个长度。典型的应用场景如存储密码的MD5值。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;BLOB 和 TEXT&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;同样包含一个家族，TINYXXX，SMALLXXX，XXX， MEDIUMXXX，LONGXXX， 其中XXX和SMALLXXX是同义词。与其它类型不同，MySQL会把BLOB和TEXT最为一个独立对象处理，存储引擎通常采用指针+外部实际存储区域。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ENUM&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;值域有限的时候可以用ENUM来代替VARCHAR。ENUM背后是整型。&lt;/p&gt;
&lt;h4 id=&#34;heading-7&#34;&gt;日期和时间类型&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;DATETIME，从1001到9999年，精度为秒，使用8字节&lt;/li&gt;
&lt;li&gt;TIMESTAMP，精度也为秒，4字节。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;mysql-schema-&#34;&gt;MySQL schema 设计中的陷阱&lt;/h3&gt;
&lt;p&gt;太多的列， 太多Join，刻意避免NULL（改用的时候可以用NULL，有时候default value可能会引入程序bug）&lt;/p&gt;
&lt;h3 id=&#34;heading-8&#34;&gt;范式和反范式&lt;/h3&gt;
&lt;p&gt;应该根据应用场景混合使用&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;优点&lt;/th&gt;
&lt;th&gt;缺点&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;范式&lt;/td&gt;
&lt;td&gt;（通常情况下）更新操作性能更好&lt;/td&gt;
&lt;td&gt;需要多个join时，读取性能低&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;反范式&lt;/td&gt;
&lt;td&gt;查询性能改好（顺序IO vs  随机IO）&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;heading-9&#34;&gt;缓存表和汇总表&lt;/h3&gt;
&lt;p&gt;缓存其实不一定用MySQL来做，如果有其它中间件像redis，应该更好。&lt;/p&gt;
&lt;p&gt;有一些工具可以提供物化视图，可以监听MySQL的binlog来更新物化视图。&lt;/p&gt;
&lt;p&gt;这些技术实际上都是为了提升查询性能。&lt;/p&gt;
&lt;h3 id=&#34;alter-table&#34;&gt;加快ALTER TABLE操作的速度&lt;/h3&gt;
&lt;p&gt;alter table这个指令太重，通常会创建新的表再从旧表中拷贝所有数据到新表，是一个阻塞的操作。这个部分提到的优化实际上就是将创建+拷贝的操作移到备份库中，（进行双写），等数据一致的时候再执行轻量的“rename”操作来达成alter table的目的。&lt;/p&gt;
&lt;h2 id=&#34;5-&#34;&gt;第5章 创建高性能的索引&lt;/h2&gt;
&lt;h3 id=&#34;heading-10&#34;&gt;索引基础&lt;/h3&gt;
&lt;p&gt;常见的索引包括B-tree(B+tree)和哈希字典。因为构建方式的不同，因此查询的时间复杂度也不一样。理解了索引的构建方式，才能让查询真正享受索引带来的性能优化。比如，B-tree索引，适用于根据最左前缀的查找，但是不能用于尾缀查询。又比如，哈希索引不能进行范围查找。&lt;/p&gt;
&lt;h3 id=&#34;heading-11&#34;&gt;索引优点&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;大大减少需要扫描的数据量&lt;/li&gt;
&lt;li&gt;避免排序和临时表。（这个没有感受，不过想B-tree这种索引确实是已经排序好的）&lt;/li&gt;
&lt;li&gt;将随机IO变为顺序IO。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;heading-12&#34;&gt;高性能的索引策略&lt;/h3&gt;
&lt;h4 id=&#34;heading-13&#34;&gt;独立的列&lt;/h4&gt;
&lt;p&gt;应该将包含索引的列单独放在比较符号的一侧。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;WHERE id + 1 = 5&lt;/code&gt; vs &lt;code&gt;WHERE id = 4&lt;/code&gt;, 前者是全表扫描，而后者能利用索引。&lt;/p&gt;
&lt;h4 id=&#34;heading-14&#34;&gt;前缀索引&lt;/h4&gt;
&lt;p&gt;如果为很长的字符创设置索引，会让索引变得很大很慢。可以通过给固定长度的前缀设计索引来改善这一问题。当然这势必导致一个唯一的索引值可能指向多个数据表记录。&lt;/p&gt;
&lt;h4 id=&#34;heading-15&#34;&gt;多列索引&lt;/h4&gt;
&lt;p&gt;TODO： 多列索引究竟是怎么实现的，为什么相对为每个列单独建一个索引更有优势？&lt;/p&gt;
&lt;p&gt;需要多列索引的情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当需要对多个索引做相交操作时（多个AND条件）&lt;/li&gt;
&lt;li&gt;当需要对多个索引做联合操作（多个OR）？！！！ 这里没看懂&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;heading-16&#34;&gt;选择合适的索引列顺序&lt;/h4&gt;
&lt;p&gt;通常应该将选择性大的放在前面&lt;/p&gt;
&lt;h4 id=&#34;heading-17&#34;&gt;聚簇索引&lt;/h4&gt;
&lt;p&gt;聚簇索引是指数据行放在索引的叶子页。&lt;/p&gt;
&lt;p&gt;聚簇索引和非聚簇索引的布局区别如下图所示。因为聚簇索引在叶子页保存了整个数据行，因此一个表也就只能存在一个聚簇索引，而这就是表的主键。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://xiaoqihai.oss-cn-shanghai.aliyuncs.com/img/20210204150359.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;对于聚簇索引，有几点要引起额外关注：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;插入速度严重依赖于插入顺序。其实就是B-tree分裂的问题，因为聚簇索引数据也在叶子页，因此分裂的可能性就更大，同时分裂的时候需要移动的数据也更多，也更容易造成碎片。&lt;/li&gt;
&lt;li&gt;更新索引列代价很高。因为移动的数据太多。&lt;/li&gt;
&lt;li&gt;二级索引会更大。不过这个算是一个trade-off了，毕竟不用聚簇索引的话，每次更新都要更新所有二级索引的“指针”。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;鉴于上述问题，一般建议MySQL的主键用自增整数，顺序插入。因为是顺序插入的，每条记录都是在上条记录之后，如果达到了分裂因子，下一条记录就会写在了新页中。从整体上，移动的数据变量变小，而且基本上是顺序写，性能高。&lt;/p&gt;
&lt;h4 id=&#34;heading-18&#34;&gt;覆盖索引&lt;/h4&gt;
&lt;p&gt;前面聚簇索的情况中，通过二级索引查找数据，需要查找两次索引。一次是二级索引本身，通过此二级索引找到对应的聚簇索引的键值，再以此键值在聚簇索引上查找需要的数据。&lt;/p&gt;
&lt;p&gt;而覆盖索引，就是索引在叶子页也存储了可能关心的若干列的数据，这样就不需要二次查询了。&lt;/p&gt;
&lt;p&gt;其实这也是一种通过冗余数据来提升读性能的办法，随之而来也是这种方式常见的问题，比如空间消耗、数据一致性（更新操作麻烦）等。&lt;/p&gt;
&lt;p&gt;// 剩下的几个小节是索引优化和排序相关的问题，因为没有遇到就跳过了。这些内容都是受限于具体索引的实现，现在深入学习没有必要，因为引擎本身可能变，这些优化方式也可能变或者自动化。&lt;/p&gt;
&lt;h2 id=&#34;6-&#34;&gt;第6章 查询性能优化&lt;/h2&gt;
&lt;h3 id=&#34;heading-19&#34;&gt;慢查询基础：优化数据访问&lt;/h3&gt;
&lt;p&gt;两个步骤依次进行&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;确认应用程序是否检索了大量超过实际需要的数据。&lt;/li&gt;
&lt;li&gt;确认MySQL服务器是否分析了大量超过需要的数据。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;heading-20&#34;&gt;查询执行的基础知识&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://xiaoqihai.oss-cn-shanghai.aliyuncs.com/img/20210204174817.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;heading-21&#34;&gt;客户端/服务端通信协议&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;半双工&lt;/strong&gt; 服务端和客户端都可以向彼此发送消息的，但是一旦一端开始发送消息，另一端需要收完整个消息之后才能响应。&lt;/p&gt;
&lt;p&gt;因为这个通信方式，通常在查询的时候最好加上LIMIT限制。&lt;/p&gt;
&lt;h4 id=&#34;heading-22&#34;&gt;查询缓存&lt;/h4&gt;
&lt;p&gt;是对Query及其Query结果的缓存。缓存命中可以跳过后续步骤&lt;/p&gt;
&lt;h4 id=&#34;heading-23&#34;&gt;查询优化处理&lt;/h4&gt;
&lt;p&gt;和编译原理中的东西很相似，先做静态的解析和优化（等价转换），动态优化通过一些列办法来评估各种查询计划可能的成本，并从中选择一个最低的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;针对优化器的目前特性而做的“优化”其实必要性不是很大，除非这个优化确实被证实了目前系统的性能瓶颈所在，否则不仅看不见收益，还可能让代码变得更不容易维护，甚至这些“优化”可能在后续版本中反而降低性能。因此这部分我看得不是很仔细，如果生产中遇到了这些问题，再针对当前的环境来做分析。&lt;/strong&gt;&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Kubernetes 官方文档学习笔记</title>
      <link>http://auntlei.com/post/reading/kubernetes/</link>
      <pubDate>Fri, 09 Oct 2020 15:50:47 +0800</pubDate>
      
      <guid>http://auntlei.com/post/reading/kubernetes/</guid>
      
        <description>&lt;h2 id=&#34;kubernetes-&#34;&gt;kubernetes 解决了什么问题&lt;/h2&gt;
&lt;p&gt;kubernetes解决了容器部署应用场景中&lt;strong&gt;部署流程&lt;/strong&gt;、**故障自动检测与转移（failover）**这两个最基本的问题。其它能力都可以被认作是衍生的能力，比如容期间的负载均衡、服务发现、打包镜像、密钥管理等。我之所以认为它们是衍生能力是因为，哪怕没有kubernetes，我们也能通过其他成熟方案解决。&lt;/p&gt;
&lt;h2 id=&#34;heading&#34;&gt;架构&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://xiaoqihai.oss-cn-shanghai.aliyuncs.com/img/20201010155239.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;kubernets架构可以分为控制面和节点。其中控制面管理整个集群的信息并对提供操作接口，而节点作为具体的物理资源则负责运行容器任务。&lt;/p&gt;
&lt;p&gt;TODO：各模块定位&lt;/p&gt;
&lt;h3 id=&#34;heading-1&#34;&gt;控制面&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;api server  是kubernetes的控制面的入口，暴露了kubernetes的服务接口&lt;/li&gt;
&lt;li&gt;control manager 用于监听、管理集群的事件，包括节点管理器、副本管理器等&lt;/li&gt;
&lt;li&gt;kube-scheduler 负责为Pod分配节点等调度任务&lt;/li&gt;
&lt;li&gt;cloud control manager(可选) 对公有云资源进行包装，使得kubernetes能管理公有云的资源，而不仅仅是企业内部机房。&lt;/li&gt;
&lt;li&gt;etcd 存储元信息&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;heading-2&#34;&gt;节点&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;kubelet 负责在节点上运行pod&lt;/li&gt;
&lt;li&gt;kube-proxy 管理节点上的网络、并且提供部分kubernetes服务接口。（这个定位感觉比较模糊，以后可能还会再拆吧？）&lt;/li&gt;
&lt;/ul&gt;</description>
      
    </item>
    
    <item>
      <title>《Docker Deep Dive》读书笔记</title>
      <link>http://auntlei.com/post/reading/dockerdeepdive/</link>
      <pubDate>Thu, 03 Sep 2020 14:50:13 +0800</pubDate>
      
      <guid>http://auntlei.com/post/reading/dockerdeepdive/</guid>
      
        <description>&lt;h2 id=&#34;heading&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;本书比较浅显，介绍了Docker的组成，并简单地介绍了工作原理。阅读次数，有助于理解Docker技术中的几个关键概念，比如Image、Container，Swarm, overlay network。&lt;/p&gt;
&lt;p&gt;下一步计划阅读、学习kubernetes。&lt;/p&gt;
&lt;h2 id=&#34;heading-1&#34;&gt;重要章节笔记&lt;/h2&gt;
&lt;h3 id=&#34;5-the-docker-engine&#34;&gt;5. The Docker Engine&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;dockercli 作为用户交互的入口将dockerd的接口封装之后暴露给用户使用&lt;/li&gt;
&lt;li&gt;dockerd 更像是一个网关服务，接受dockercli的请求并将其转发给后端containerd&lt;/li&gt;
&lt;li&gt;containerd 负责管理容器的生命周期、以及镜像、网络等事务&lt;/li&gt;
&lt;li&gt;runc作为独立的程序被containerd用于启动运行容器&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://xiaoqihai.oss-cn-shanghai.aliyuncs.com/img/20200927122808.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;6-images&#34;&gt;6. Images&lt;/h3&gt;
&lt;p&gt;Image 是一个静态的描述文件，类似VM template（注意不是VM snapshot， Image并不能表达出内存所处的状态），而container则是从image创建而来的运行态的“应用容器”。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://xiaoqihai.oss-cn-shanghai.aliyuncs.com/img/20200927122943.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://xiaoqihai.oss-cn-shanghai.aliyuncs.com/img/20200927142837.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;一个image由若干个&lt;strong&gt;只读&lt;/strong&gt;层组成，位于上层的文件将隐藏下层的同名文件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://xiaoqihai.oss-cn-shanghai.aliyuncs.com/img/20200927123132.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;8-containerizing-an-app&#34;&gt;8 containerizing an app&lt;/h3&gt;
&lt;p&gt;DockerFile 描述了如何创建一个image。这些指令可以分为两类，一类会创建新的层，而另一类则仅仅是添加元数据。要注意如何编写DockerFile来优化镜像大小。&lt;/p&gt;
&lt;h3 id=&#34;9-swarm-mode&#34;&gt;9 Swarm Mode&lt;/h3&gt;
&lt;p&gt;Docker的集群模式。参与到swarm中的节点被分为manager 和worker。manager 负责管理整个集群（docker的术语为swarm），具体管理哪些书本并没有细说，不过这个不重要。和其它系统一样，manager就是一个高可用的管理服务，而worker则是无状态的（？）的执行任务的工具人。&lt;/p&gt;
&lt;p&gt;Swarm模式为了保证高可用，使用了etcd。&lt;/p&gt;
&lt;h3 id=&#34;10-docker-overlay-network&#34;&gt;10 Docker overlay network&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://xiaoqihai.oss-cn-shanghai.aliyuncs.com/img/20200929144523.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;docker overlay network 是一个在docker节点之间基于应用层网络虚拟出来的2层&lt;a href=&#34;https://www.practicalnetworking.net/stand-alone/vlans/&#34;&gt;vlan&lt;/a&gt;，使得位于不同物理节点上的container处于同一个虚拟的2层子网之中。如何在应用层实现vlan则依赖&lt;a href=&#34;https://en.wikipedia.org/wiki/Virtual_Extensible_LAN&#34;&gt;vxlan&lt;/a&gt; 技术。这种软件定义的网络（SDN）可以拥有更多的特性，比如通过加密来保证通信安全。&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Redis 学习笔记</title>
      <link>http://auntlei.com/post/middleware/redis/</link>
      <pubDate>Thu, 04 Jun 2020 10:43:05 +0800</pubDate>
      
      <guid>http://auntlei.com/post/middleware/redis/</guid>
      
        <description>&lt;p&gt;虽然自己看了两本关于redis的书《redis深度历险&amp;ndash;核心原理与应用实践》《redis运维与开发》，但是redis整体比较简单，随便找点资料学习即可满足平时开发的需求。&lt;/p&gt;
&lt;h2 id=&#34;redis-&#34;&gt;Redis 是什么？&lt;/h2&gt;
&lt;p&gt;纯内存、支持多种数据结构的键-值数据库。&lt;/p&gt;
&lt;p&gt;纯内存指左右的数据都放在内存，即从redis取数据并不会发生磁盘I/O（假设没有内存也swap进硬盘）。这和数据持久化并不冲突。&lt;/p&gt;
&lt;p&gt;键-值，即redis存储数据的方式，所有的数据都与一个键相关联，而值可能是多种数据结构中的一种。&lt;/p&gt;
&lt;h3 id=&#34;redis--1&#34;&gt;redis 提供的能力&lt;/h3&gt;
&lt;h4 id=&#34;heading&#34;&gt;支持的数据结构&lt;/h4&gt;
&lt;p&gt;String, List，Set, Hash, Zset(order set)&lt;/p&gt;
&lt;p&gt;更高级一点的数据结构包括： bitmap, 布隆过滤器、hyperloglog&lt;/p&gt;
&lt;h4 id=&#34;heading-1&#34;&gt;架构（单机）&lt;/h4&gt;
&lt;p&gt;单线程，多路IO复用（epoll）&lt;/p&gt;
&lt;h4 id=&#34;heading-2&#34;&gt;高级功能&lt;/h4&gt;
&lt;h5 id=&#34;heading-3&#34;&gt;事务&lt;/h5&gt;
&lt;p&gt;相关的命令包括, &lt;code&gt;DISCARD&lt;/code&gt;,&lt;code&gt;EXEC&lt;/code&gt;,&lt;code&gt;MULTI&lt;/code&gt;,&lt;code&gt;WATCH&lt;/code&gt;,&lt;code&gt;UNWATCH&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;事务始于&lt;code&gt;multi&lt;/code&gt;命令，mulit命令执行后告诉redis server将此client后续的命令放入队列中（等待执行），直到&lt;code&gt;exec&lt;/code&gt;时，将此client已经入队的指令，&lt;strong&gt;串行&lt;/strong&gt; 顺序执行，或者到&lt;code&gt;discard&lt;/code&gt;指定将所有入队的指令抛弃。&lt;/p&gt;
&lt;p&gt;对于事务，redis保证两点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;事务中所有指令在执行的过程中不会插入其它client的指令&lt;/li&gt;
&lt;li&gt;所有指令要么都执行，要么都不执行。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;对于其中的第2点，需要强调的是如果事务中有一个命令出错，redis并不会想常见的数据库那样回滚（rollback）所有改动，而是接着执行后续指令。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;watch&lt;/code&gt;命令用于multi之前，用于声明指定的key在watch之后与 multi之前，不能发生任何修改（包括同client的修改）。但是这些key可以在事务中被修改。&lt;/p&gt;
&lt;p&gt;例1, watch 和multi之间，此client修改了watch的key，事务依旧不会被执行（exec 返回nil)&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;127.0.0.1:6379&amp;gt; watch foo
OK
127.0.0.1:6379&amp;gt; set foo 2
OK
127.0.0.1:6379&amp;gt; multi
OK
127.0.0.1:6379&amp;gt; set foo 1
QUEUED
127.0.0.1:6379&amp;gt; exec
(nil)
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;例2， watch和multi之间，别的client修改了key&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;client 1
127.0.0.1:6379&amp;gt; watch foo
OK

client 2
127.0.0.1:6379&amp;gt; set foo 2
OK

client 1
127.0.0.1:6379&amp;gt; multi
OK
127.0.0.1:6379&amp;gt; set foo 1
QUEUED
127.0.0.1:6379&amp;gt; exec
(nil)
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h5 id=&#34;pubsub-&#34;&gt;pub/sub 消息通知&lt;/h5&gt;
&lt;p&gt;subscribe 可以监听指定的key（此时key被视作消息的信道），而&lt;em&gt;p&lt;/em&gt;subscribe 可以以监听符合固定pattern的所有key（哪怕这些key是之后创建的）&lt;/p&gt;
&lt;p&gt;消息是广播的机制，即所有的subscriber都会受到发布的消息。&lt;/p&gt;
&lt;p&gt;但是整体上，redis的pub/sub系统很简单，并没有想kafka这种消息系统复杂的功能（比如offset等）。&lt;/p&gt;
&lt;h5 id=&#34;stream&#34;&gt;stream&lt;/h5&gt;
&lt;p&gt;目前声场环境没有这个功能，没有做太多的研究。&lt;/p&gt;
&lt;p&gt;5.0新增feature，初看下来是pub/sub的升级版，但是真需要这些功能的时候可能选择kafka更合适。&lt;/p&gt;
&lt;h2 id=&#34;heading-4&#34;&gt;使用场景&lt;/h2&gt;
&lt;h3 id=&#34;redis-vs-memcached&#34;&gt;redis vs memcached&lt;/h3&gt;
&lt;p&gt;海量数据场景下，对数据结构也没有什么要求，可以使用memcached充分发挥机器的计算资源。其它场景用redis 没有问题&lt;/p&gt;
&lt;h3 id=&#34;heading-5&#34;&gt;作为缓存&lt;/h3&gt;
&lt;p&gt;这是redis用的最多的场景&lt;/p&gt;
&lt;h3 id=&#34;heading-6&#34;&gt;多进程共享数据&lt;/h3&gt;
&lt;p&gt;其实这也可以算作缓存的一种方式&lt;/p&gt;
&lt;h3 id=&#34;heading-7&#34;&gt;分布式锁&lt;/h3&gt;
&lt;p&gt;通过 SET NX（non-existing) PX (expire) 的方式可以实现简单的分布式锁。但是如果你的系统需要更严格的选主功能，应该使用想zookeeper这种中间件。&lt;/p&gt;
&lt;h3 id=&#34;heading-8&#34;&gt;分布式限流&lt;/h3&gt;
&lt;p&gt;将redis作为一个集中的计算点，以时间窗口为key，可以实现简单的计数器限流算法。如果配合lua使用，可以实现令牌桶等限流算法。基本思想其实就是将令牌的生成集中到一个系统计算完成（这里的redis）。&lt;/p&gt;
&lt;h2 id=&#34;heading-9&#34;&gt;高可用与分布式&lt;/h2&gt;
&lt;h3 id=&#34;redis-sentinel&#34;&gt;redis sentinel&lt;/h3&gt;
&lt;p&gt;通过sentinel在多个redis中选取master来保证高可用。但是因为master和slave之间采用异步复制的方式，因此在切换master期间可能丢失部分数据。&lt;/p&gt;
&lt;h3 id=&#34;redis-cluster&#34;&gt;redis cluster&lt;/h3&gt;
&lt;p&gt;就是数据分片。通过将数据分散到不同的redis 节点上来达到横向扩容的目的。&lt;/p&gt;
&lt;h2 id=&#34;redis-cheat-sheet&#34;&gt;附：redis cheat sheet&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://cheatography.com/tasjaevan/cheat-sheets/redis/&#34;&gt;https://cheatography.com/tasjaevan/cheat-sheets/redis/&lt;/a&gt;&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>《数据密集型应用系统设计》笔记</title>
      <link>http://auntlei.com/post/reading/designing_data-intensive_applications/</link>
      <pubDate>Wed, 15 Apr 2020 09:49:17 +0800</pubDate>
      
      <guid>http://auntlei.com/post/reading/designing_data-intensive_applications/</guid>
      
        <description>&lt;p&gt;这本书互联网从业者实践意义巨大，强烈推荐。&lt;/p&gt;
&lt;h2 id=&#34;-&#34;&gt;第一部分 数据系统基础&lt;/h2&gt;
&lt;h3 id=&#34;1-&#34;&gt;第1章 可靠、可扩展与可维护的应用系统&lt;/h3&gt;
&lt;p&gt;当今许多新型应用都属于数据密集型( data-intensi ve)，而不是计算密集型 (compute-intensive)。对于这些类型应用， CPU的处理能力往往不是第一限制性因素，关键在于数据量、数据的复杂度及数据的快速多变性。&lt;/p&gt;
&lt;p&gt;设计这类系统需要考虑三类问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可靠性（Reliability）。当出现意外情况如硬件、软件故障、人为失误等，系统应可以继续正常运转:虽然性能可能有所降低，但确保功能正确。&lt;/li&gt;
&lt;li&gt;可扩展性 (Scalability)。随着规模的增长 ，例如数据量 、流量或复杂性，系统应以合理的方式来匹配这种增长。&lt;/li&gt;
&lt;li&gt;可维护性 (Maintainability)。随着时间的推移，许多新的人员参与到系统开发和运维， 以维护现有功能或适配新场景等，系统都应高效运转。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;既然我们已经明确了设计目标，那么怎么检测我们的系统是否满足这三个特性呢？我认为系统监控是检验的核心，我们需要有办法了解系统是否按照我们期望的方式运行。而监控的第一步就是要&lt;em&gt;明确衡量指标&lt;/em&gt;，比如系统占用了多少资源（CPU，内存，磁盘）、响应时间（p50,p99,p999)等。只有当监控指标明确之后，我们才能检测系统在出错下是否可靠，是否具备横向/纵向的可扩展能力。监控对于可维护性来说则更为重要，监控能增强运维改动的信心，及时发现问题。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;2-&#34;&gt;第2章 数据模型与查询语言&lt;/h3&gt;
&lt;p&gt;TODO: 这部分关于各种数据模型的介绍，尤其是图数据模型没有看明白&lt;/p&gt;
&lt;h3 id=&#34;3-&#34;&gt;第3章 数据存储与检索&lt;/h3&gt;
&lt;p&gt;数据库最基本的两个能力是插入时能保存数据，并且在以后的查询中能返回这些数据。&lt;/p&gt;
&lt;p&gt;数据库采用的数据结构决定了其读写性能及空间利用率。对于写入，顺序写入的性能往往比随机写入高出几个数量级。因为操作系统能对外部存储的大块区域进行缓存，因此顺序/随机读取的性能不如写入影响那么明显。&lt;/p&gt;
&lt;h4 id=&#34;heading&#34;&gt;数据结构&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;哈希索引&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;假设数据存储全部采用追加式文件组成，那么最简单的索引策略就是: 保存内存中的hash map，把每个键一一映射到数据文件中特定的字节偏移量，这样就可以找到每个值的位置。如果数据文件有多份，那么对应在内存中也就可能有多份hash map。&lt;/p&gt;
&lt;p&gt;这种方式比较适合更新频繁的场景但是不能解决范围查询的问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SSTables和LSM-tree&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;要解决范围查询，将哈希索引转换成一种有序的数据结构，比如红黑树。如果数据文件中的记录也是排序的，那么将数据文件中的键稀疏地映射到内存中，就可以通过内存中的索引查找到给定key在数据文件中的可能范围。配合WAL可以保证写入先缓存在内存中，然后一次将整个sstable写入文件（追加）。为提升查询效率，可以使用布隆过滤器。&lt;/p&gt;
&lt;p&gt;LSM-tree合并有两种方式，size-tiered compaction 与 leveled compaction 书中解释得不够清晰，补充在这里：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;size-tiered compaction是指将SSTable分为多个阶梯（tier）每个阶梯有固定数目（sized)的sstable文件，当一个阶梯的sstable数量达到size大小时，将他们compact成一个更大的sstable并放到下一个tier，如果下一个tier的数目达到阈值则继续compact。&lt;/li&gt;
&lt;li&gt;leveled compaction: rocksdb的这篇文章介绍得很清楚https://github.com/facebook/rocksdb/wiki/Leveled-Compaction
基本思想时，将sstable分成不同的level，并且每个level内的sstable 范围互不重叠。而单个sstable大小固定，不同的level总大小递增，因此level越高的层，具有越多的sstable。因为sstable的大小固定，所以当上层的sstable与下层的sstable合并时，可能会产生新的sstable，当一层的数据总大小超过限制时，会从中选择一个（随机？）sstable合并到下一层。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;B tree&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;B+tree 使用很常见了。如果是in-place修改就使用WAL，append-only可以不使用WAL。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;其他索引&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;聚簇索引&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;索引和数据存储在一块（ 都存储在同一个B*tree 中）。
一般主键索引都是聚餐索引&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;非聚簇索引&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;索引数据和存储数据是分离的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;二级索引（辅助索引）&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;二级索引存储的是记录的主键，而不是数据存储的地址。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;多列索引&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;同时为多列建立索性，传统的b tree， lsm都不能解决这个问题，需要专门的结构。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;heading-1&#34;&gt;数据处理与分析处理&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://xiaoqihai.oss-cn-shanghai.aliyuncs.com/img/20200416161154.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;heading-2&#34;&gt;列式存储&lt;/h4&gt;
&lt;p&gt;在分析处理过程（大数据处理）虽然一个记录可能有上百列，但是单次分析需要的数据通常就其中的三四列。因此按列存储能提升查询性能，并且由于列的值域可能小于行数（或者列与列之间重复的内容比较多），因此也容易做压缩。&lt;/p&gt;
&lt;h3 id=&#34;4-&#34;&gt;第4章 数据编码与演化&lt;/h3&gt;
&lt;h4 id=&#34;heading-3&#34;&gt;数据编码（序列化）&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;编程语言特定的编码仅限于某一种编程语言，往往无法提供向前和向后兼容性。&lt;/li&gt;
&lt;li&gt;JSON、 XML和csv等文本格式非常普遍，其兼容性取决于你如何使用他们。这些格式对某些数据类型的支持有些模糊，**必须小心处理数字（比如json的精度问题）**和二进制字符串等问题。&lt;/li&gt;
&lt;li&gt;像Thrift、 Protocol Buffers和Avro这样的二进制的模式驱动格式，支持使用清晰定义的向前和向后兼容性语义进行紧凑、高效的编码。这些模式对于静态类型语言中的文档和代码生成非常有用。然而，它们有一个缺点，即只有在数据解码后才是人类可读的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在编码向前、向后兼容的时候，对新增字段有一个需要特别注意的地方。当新版本增加了一个字段假设为F，虽然老版本的程序在反序列化是会忽略这个值（向后兼容），但是在写回时得务必小心，防止丢弃数据（F的值变为了默认值）。&lt;/p&gt;
&lt;h4 id=&#34;heading-4&#34;&gt;数据流的传输方式&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;数据库，其中写入数据库的进程对数据进行编码，而读取数据库的进程对数据进&lt;/p&gt;
&lt;p&gt;行解码。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;RPC和REST API，其中客户端对请求进行编码，服务器对请求进行解码井对响&lt;/p&gt;
&lt;p&gt;应进行编码，客户端最终对响应进行解码。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;异步消息传递(使用消息代理或Actor)，节点之间通过互相发送消息进行通 信，消息由发送者编码并由接收者解码&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中对于消息代理方式，其好处表现为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果接收方不可用或过载，它可以充当缓冲区，从而提高系统的可靠性。&lt;/li&gt;
&lt;li&gt;它可以自动将消息重新发送到崩愤的进程，从而防止消息丢失 。 (&lt;strong&gt;这个不是免费的，要自己想办法实现，保证消息在生产、传递、消费的各个环节中的可靠性。但是可靠性的保证不外乎就是事务的支持，以及在重复处理时的幂等问题&lt;/strong&gt;)&lt;/li&gt;
&lt;li&gt;它在逻辑上将发送方与接收方分离，解耦&lt;/li&gt;
&lt;li&gt;它支持将 一 条消息发送给多个接收方。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;--&#34;&gt;第二部分 分布式数据系统 （本书精华，对实践具有一定的指导意义）&lt;/h2&gt;
&lt;h3 id=&#34;5-&#34;&gt;第5章 数据复制&lt;/h3&gt;
&lt;h4 id=&#34;heading-5&#34;&gt;按角色定位分&lt;/h4&gt;
&lt;p&gt;按照节点的角色不同，分为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主从复制：只有主节点接收写请求。&lt;/li&gt;
&lt;li&gt;多主复制：有多个主节点，主节点都可以接收写请求。&lt;/li&gt;
&lt;li&gt;无主复制：所有节点都是主节点。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中，最常见的是主从复制。通过从节点来提升系统整体的读性能。但是这种方式在业务跨多数据中心时，如果让所有的写入都定打到到一个数据中心可能达不到业务需求。因此对于多数据中心常常使用多主复制的策略。如下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://xiaoqihai.oss-cn-shanghai.aliyuncs.com/img/20200417145230.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;在单个数据中心内使用主从复制，但是多数据中心使用多主的策略。&lt;/p&gt;
&lt;p&gt;而无主复制更为极端，所有的节点都没有主从之分，常见于多人协同在线文档的场景等。&lt;/p&gt;
&lt;h4 id=&#34;heading-6&#34;&gt;数据复制方式&lt;/h4&gt;
&lt;p&gt;从时效性上可以分为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;同步复制 接收写入的节点要等到指定个（不一定是所有）节点完成复制之后才向客户端返回结果&lt;/li&gt;
&lt;li&gt;异步复制 接收写入的节点完成修改后立即向客户端发挥结果，之后再将修改发送到其他节点。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;同步复制虽然更容易保证数据的一致性，但是由于复制的延迟问题，会使得整个系统的写入变慢，尤其当有多个同步复制的节点时。所以在实践中，哪怕是主从复制，也不会将所有的从节点都配置成同步复制。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;复制日志的实现&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基于语句复制。几乎不用，因为有些语句比如Now()在重放时，每个节点都可能有不同的值&lt;/li&gt;
&lt;li&gt;基于WAL。有很多软件使用。如果WAL描述的是物理介质上某偏移字节的修改，那么这种复制方式在跨软件版本时可能有问题。比如不能实现软件版本的滚动升级。&lt;/li&gt;
&lt;li&gt;基于行的逻辑日志复制。复制和存储引擎采用不同的日志格式，这样复制与存储逻辑剥离。MySQL的binlog就属于这种方式。&lt;/li&gt;
&lt;li&gt;基于触发器。数据库软件支持一些触发器（比如onCommit)，可以在这些触发器中实现自定义的复制逻辑。虽然定制化程度高，但是容易出错。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;heading-7&#34;&gt;复制的问题&lt;/h4&gt;
&lt;p&gt;所有这些问题都没有很好的解决方案，是设计时的权衡。因此一定要仔细考虑服务在各种意外场景下的表现行为，并和所有关联方进行确认。保证数据的一致性是后面章节的内容，这里没有特别通用的方法&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据丢失&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;读滞后&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;用户在主节点写入，紧接着从从节点读取。从节点可能还没有完成数据复制。解决方案可能是“读自己写”&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;写冲突&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;6-&#34;&gt;第6章 数据分区&lt;/h3&gt;
&lt;p&gt;分区通常与复制结合使用，即每个分区在多个节点都存有副本。分区主要是为了提升海量数据的读&lt;strong&gt;写&lt;/strong&gt;性能。如果分区负载均匀，那么可以成分区倍数地提升系统的读写吞吐量，但是如果分区不均，则可能少数节点承载了系统的多数请求，出现倾斜的现象。&lt;/p&gt;
&lt;p&gt;分区有两种方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基于区间。容易出现热点，但是方便实现区间查询&lt;/li&gt;
&lt;li&gt;基于哈希值。流量更随机，但区间查询效率不高&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果涉及二级索引，根据其是否和数据分区规则一致又可以分为两种方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;本地索引。二级索引存储在与关键字相同的分区中 ，这意味着写入时我们只需要更新一个分区，但缺点是读取二级索引时需要在 所有分区上执行 scatter/gather。&lt;/li&gt;
&lt;li&gt;全局索引。它是基于索引的值而进行的独立分区。 二级索引中的条目可能包含来自关键字的多个分区里的记录。在写入时 ，不得不更新二级索引的多个分区;但读取时 ，则可以从单个分区直接快速提取数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;7-&#34;&gt;第7章 事务&lt;/h3&gt;
&lt;h4 id=&#34;heading-8&#34;&gt;事务的定义不够精确&lt;/h4&gt;
&lt;p&gt;提到事务，大家都知道ACID，对应：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Atomicity（原子性)）指的是All or Nothing，即事务中的所有更新要么都发生、要么都不发生。它并不关乎多个操作的并发性，它并没有描述多个线程试图访问相同的数据会发生什么情况，后者其实是由 ACID的&lt;strong&gt;隔离性&lt;/strong&gt;所定义。&lt;/li&gt;
&lt;li&gt;Consistency（一致性）指对数据有特定的预期状态，任何数据更改必须满足这些 状态约束(或者恒等条件)。例如，对于一个账单系统，账户的贷款余额应和借款余 额保持平衡。如果某事务从一个有效的状态开始，并且事务中任何更新操作都没有违背约束，那么最后的结果依然符合有效状态。但这实际上是一种应用层的状态约束，不是数据库可以保证的。&lt;/li&gt;
&lt;li&gt;Isolation（隔离性）并发执行的多个事务相互隔离，它们不能互相交叉。但是这并不意味着事务之间的执行就好比是串行化执行一样，这其中又分为多种不同的“弱隔离级别”&lt;/li&gt;
&lt;li&gt;Durability（持久性）一 且事务提交成功，即使存在硬件故障或数据库崩愤，事务所 写入的任何数据也不会消失。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;weak-isolation-levels&#34;&gt;弱隔离级别（Weak Isolation Levels）&lt;/h4&gt;
&lt;p&gt;这部分作者的规律有些不清晰，以后再补充&lt;/p&gt;
&lt;h3 id=&#34;8-&#34;&gt;第8章 分布式系统的挑战&lt;/h3&gt;
&lt;p&gt;这张主要阐述三类问题对分布式系统带来的挑战：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;网络不可靠。数据包可能会丢失或者延迟。当没有收到对方节点回应时，也不能确定消息是否送达，因此消息也可能存在重放的问题。&lt;/li&gt;
&lt;li&gt;时钟不同步。由于网络延迟的不确定性，通过NTP服务也不能保证节点间的时钟同步。另外由于节点时钟频率可能和NTP服务器的时钟频率存在差异，可能在节点上观测到时钟先前或者先后的跳跃。如果需要在单节点上测量时间差，可以使用线性时间。时钟的不同步，使得我们不可能简单地靠时间戳来判断事件发生的先后顺序。&lt;/li&gt;
&lt;li&gt;进程可能在执行的任意时刻暂停任意时长。比如一些语言的垃圾回收器会Stop The World，或者位于虚拟机中的容器可能被宿主机暂停任意时长。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;9-&#34;&gt;第9章 一致性与共识&lt;/h3&gt;
&lt;p&gt;本章主要是还是概念性的知识。（TODO）&lt;/p&gt;
&lt;h2 id=&#34;--1&#34;&gt;第三部分 派生数据&lt;/h2&gt;
&lt;p&gt;第三部分整体看起来别扭，可能和翻译质量有关。这部分总结比较少。&lt;/p&gt;
&lt;h3 id=&#34;10-&#34;&gt;第10章 批处理系统&lt;/h3&gt;
&lt;p&gt;介绍了map-reduce的基本思想及开源软件库Hadoop的相应功能介绍。&lt;/p&gt;
&lt;p&gt;第11章 流处理系统&lt;/p&gt;
&lt;p&gt;介绍了消息队列相关的知识，其它关于流的理论性知识对实践的意义不大。由于后面会看Kafka相关的书籍，这里不做太多总结。&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>《Network Programming with Go by Jan Newmarch》</title>
      <link>http://auntlei.com/post/reading/network_programming_with_go/</link>
      <pubDate>Tue, 14 Apr 2020 10:32:30 +0800</pubDate>
      
      <guid>http://auntlei.com/post/reading/network_programming_with_go/</guid>
      
        <description>&lt;p&gt;&lt;strong&gt;这是一本很简单入门书籍，不适合对网络编程有了解，希望探索go在网络编程（socket编程）上的一些陷阱、最佳实践或者高级技巧的朋友&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;书本内容从结构上看比较丰富，首先介绍网络整体架构，接着介绍如何使用golang进行面向socket的编程，最后介绍更高层次是数据序列化以及构建简单的网络应用。但是内容落后（个别API不存在了），对于稍微有点编程经验的读者来说都过于简单，是非常初阶的只是。&lt;/p&gt;
&lt;p&gt;简单总结，这本书只是很浅显的介绍了net包下对P/TCP/UDP链接的简单使用、以及http包、TLS的介绍，剩下主要的就是各种常见序列化包的介绍了。&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>boltdb源码解析（四）—— ACID特性论证</title>
      <link>http://auntlei.com/post/source/boltdb_4/</link>
      <pubDate>Thu, 02 Apr 2020 17:07:20 +0800</pubDate>
      
      <guid>http://auntlei.com/post/source/boltdb_4/</guid>
      
        <description>&lt;p&gt;&lt;a href=&#34;http://auntlei.com/post/source/boltdb_1/&#34;&gt;boltdb源码解析（一）—— 简介&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;介绍blotdb的使用，优势与注意事项，以及源码组织结构。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://auntlei.com/post/source/boltdb_2/&#34;&gt;boltdb源码解析（二）—— 数据结构与核心算法&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;介绍核心数据结构，数据持久化到文件的物理布局，与核心算法介绍。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://auntlei.com/post/source/boltdb_3/&#34;&gt;boltdb源码解析（三）—— CURD实现细节&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;深入实现细节剖析CURD，及空闲页管理逻辑&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://auntlei.com/post/source/boltdb_4/&#34;&gt;boltdb源码解析（四）—— ACID特性论证&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;分析、证明boltdb是如何保证ACID的四个重要特性&lt;/p&gt;
&lt;p&gt;本篇将介绍事务过程中数据持久化顺序。介绍完持久化顺序之后，boltdb事务的ACID也就不言而喻了。&lt;/p&gt;
&lt;h2 id=&#34;heading&#34;&gt;事务过程中，数据化持久顺序&lt;/h2&gt;
&lt;p&gt;在介绍读写过程之前，需要简单提及下boltdb的一个特性&amp;ndash;物理文件按需增长。默认情况下boltdb在初始化时只申请最小空间（4个单位页），当数据增长时boltdb会相应增加物理文件，并重新mmap整个文件。因为golang 的&lt;code&gt;mmap&lt;/code&gt;不能指定map对象在程序虚拟地址空间（Virtual Address Space)内的偏移，重新mmap的对象可能和上次mmap的对象在虚拟地址上不一致，因此boltdb使用了一个读写锁来保护重新mmap的过程。重新map的过程中，因为写事务的inode在重新mmap之前指向的是原始页的偏移（相对拷贝整个key,value更节约内存)，因此在重新mmap的过程中需要解除写事物所有inode索引(即将inode中指向的key，value从原始页拷贝到非mmap区域——堆上）&lt;/p&gt;
&lt;h3 id=&#34;heading-1&#34;&gt;读&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://xiaoqihai.oss-cn-shanghai.aliyuncs.com/img/20200412182736.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;heading-2&#34;&gt;内存数据的一致性&lt;/h4&gt;
&lt;p&gt;唯一可能造成内存中数据不一致的情景是用户函数出错。如果使用的是托管的事务（比如DB.View)而不是直接裸用Tx，那么boltdb通过golang的recover机制保证了事务的&lt;code&gt;Rollback&lt;/code&gt;一定会被调用。而Rollback会将此事务从数据库中的数据列表中删除。哪怕用户裸用Tx，最后不调用&lt;code&gt;Rollback&lt;/code&gt;，最差的后果也只是导致数据库中维护了大于两个版本的数据； 或者因为没有释放mmapLock而导致数据需要扩大文件大小时被阻塞而无法继续。这都不会造成内存数据的不一致。当然按照约定，用户需要调用Rollback&lt;/p&gt;
&lt;h4 id=&#34;heading-3&#34;&gt;数据文件的一致性&lt;/h4&gt;
&lt;p&gt;因为读事务无法修改数据文件（任何修改操作都会出错），因此数据文件不会导致数据文件损坏。&lt;/p&gt;
&lt;h3 id=&#34;heading-4&#34;&gt;写&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://xiaoqihai.oss-cn-shanghai.aliyuncs.com/img/20200412215052&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;heading-5&#34;&gt;内存数据一致性&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;进入用户函数之前&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因为有metalock的互斥锁保护，因此回收脏页而对数据库meta的修改并不会造成内存中数据不一致。&lt;strong&gt;注意freelist结构是内存中的结构，meta中只是保存了freelist持久化的坐在页的ID。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;进入用户函数之后&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果用户函数panic会进入rollback，或者用户主动调用&lt;code&gt;Rollback&lt;/code&gt;。虽然rollback过程中会重新读取文件中的freelist，但是和内存中的pending列表合并之后，实际上并不会改变freelist的内容。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;修改数据文件之前&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;平衡B+树和序列化当前freelist 修改的是虚拟页——堆（非mmap区域）的数据，因为meta没有更新，如果出错这部分数据不会被别的事务使用，因此也不会造成内存中数据的不一致。&lt;/p&gt;
&lt;p&gt;虽然序列化事务修改后的freelist会将一些页标记成脏页，但是此时这些信息还没有被持久化，因此在rollback时将这些页从pending列表中删除之后，&lt;strong&gt;重读DB.meta指向的freelist页&lt;/strong&gt;恢复出来的freelist也是和进入事务之前是一致的。&lt;/p&gt;
&lt;p&gt;修改数据文件之后，持久化元信息之前&lt;/p&gt;
&lt;p&gt;和前面“修改数据文件之前”对内存中数据的影响没有区别，因为数据库的meta还没有更新&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;持久化元信息页之后&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;此时不会触发rollback过程，数据已经被正确更新。因为物理文件被正确更新，所以内存中的meta也是最新的了（MMAP_SHARED的保证)&lt;/p&gt;
&lt;h4 id=&#34;heading-6&#34;&gt;数据文件一致性&lt;/h4&gt;
&lt;p&gt;修改数据文件就两个地方&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;持久化数据页之后&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;此时meta没有更新，因此在程序重启时，并不会访问到这些新写的内容&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;持久化元信息页之后&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;此时meta更新，程序重启恢复时访问的就是最新数据。&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>boltdb源码解析（三）—— CURD实现细节</title>
      <link>http://auntlei.com/post/source/boltdb_3/</link>
      <pubDate>Thu, 02 Apr 2020 17:06:20 +0800</pubDate>
      
      <guid>http://auntlei.com/post/source/boltdb_3/</guid>
      
        <description>&lt;p&gt;&lt;a href=&#34;http://auntlei.com/post/source/boltdb_1/&#34;&gt;boltdb源码解析（一）—— 简介&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;介绍blotdb的使用，优势与注意事项，以及源码组织结构。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://auntlei.com/post/source/boltdb_2/&#34;&gt;boltdb源码解析（二）—— 数据结构与核心算法&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;介绍核心数据结构，数据持久化到文件的物理布局，与核心算法介绍。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://auntlei.com/post/source/boltdb_3/&#34;&gt;boltdb源码解析（三）—— CURD实现细节&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;深入实现细节剖析CURD，及空闲页管理逻辑&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://auntlei.com/post/source/boltdb_4/&#34;&gt;boltdb源码解析（四）—— ACID特性论证&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;分析、证明boltdb是如何保证ACID的四个重要特性&lt;/p&gt;
&lt;h2 id=&#34;b&#34;&gt;数据是如何以B+树的方式管理&lt;/h2&gt;
&lt;p&gt;如前文所述，物理页一共有四种类型，其中branch和leaf类型的页分别对应B+树种的中间节点和叶子节点。和元信息页一样，branch和leaf的内容也都放在页的数据区。&lt;/p&gt;
&lt;p&gt;关于B+树的定义，不同的教材有不同的定义。但是最本质的一点是一致的：所有数据（value）都只存放在叶子节点，并且所有叶子节点位于同一深度。&lt;/p&gt;
&lt;p&gt;具体的，boltdb中的B+树抽象之后如如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://xiaoqihai.oss-cn-shanghai.aliyuncs.com/img/20200412131310.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;注： 图中数字代表key， 字母代表对应的值&lt;/p&gt;
&lt;p&gt;可能和别的教材中的B+树不一样的地方在于：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;中间节点的键（key)， 是其子树第一个节点（包括叶子和中间节点）键&lt;/li&gt;
&lt;li&gt;叶子节点之间没有指针将所有的数据串联成一个链表&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;branch&#34;&gt;branch（分支）页组织方式&lt;/h3&gt;
&lt;p&gt;下图是一个中间节点序列化之后的结构&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://xiaoqihai.oss-cn-shanghai.aliyuncs.com/img/20200412124533.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;其中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;postiton&lt;/strong&gt; 表示此分支节点的key的相对与此元素起始地址的偏移&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;key size&lt;/strong&gt; key对应的字节数组长度&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;page id&lt;/strong&gt;  此分支节点的数据所在页ID&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;leaf&#34;&gt;leaf（叶子）页组织方式&lt;/h3&gt;
&lt;p&gt;相应的，下图是叶子节点序列化之后的结构&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://xiaoqihai.oss-cn-shanghai.aliyuncs.com/img/20200412132458.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;其中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;flags&lt;/strong&gt; 表示表示此叶子节点对应的值类型。应为boltdb支持多层级的bucket，所以bucket也可能是值的一种类型，而另外一种类型就是字节数组。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;position&lt;/strong&gt; 键，值相对此节点的偏移&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;key size&lt;/strong&gt; 键长度&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;value size&lt;/strong&gt; 值长度&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;branchleaf-&#34;&gt;branch、leaf 节点与键值数据的物理布局关系&lt;/h3&gt;
&lt;p&gt;这里只以leaf节点为例进行介绍，branch节点的组织方式同理。下图展示了有两个键值对（key-foo,value-foo 与 key-bar-long, value-bar-long）的物理结构。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://xiaoqihai.oss-cn-shanghai.aliyuncs.com/img/20200412141501.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;页头&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;flags: 0x2表示此页是个叶子页，count：2表示一个有两个元素，而overflow：0表示此页的数据库没有向后溢出（当数据比较大时，可能会往后溢出）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据区&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在数据区，固定大小的元素（element）位于前，而变长的数据紧接元素之后。比如，上图中一共有两个元素，依次排列在数据区的起始位置。&lt;/p&gt;
&lt;p&gt;以element-1为例说明&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;flags: 0x0 表示这个数据类型为普通的值（对应的0x1， 表示值的类型为bucket）&lt;/li&gt;
&lt;li&gt;Positon: 16 表示element的边长值从相距&lt;strong&gt;此元素&lt;/strong&gt;的第16个byte开始（也就是偏移48）&lt;/li&gt;
&lt;li&gt;key size, value size 对应的键值长度&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bucket&#34;&gt;内联（多层级）bucket支持&lt;/h3&gt;
&lt;p&gt;多层级的bucket支持很简单直观，只需要在value中保存bucket序列化之后的内容即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://xiaoqihai.oss-cn-shanghai.aliyuncs.com/img/20200412144541.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;bucket-1&#34;&gt;小bucket优化，虚拟页&lt;/h4&gt;
&lt;p&gt;有时候bucket内的所有数据加起来都远小于一个单页大小。为优化此种情况的空间开销（实际上也能提升大量小bucket情境下的性能），boltdb实现了虚拟页。&lt;/p&gt;
&lt;p&gt;当bucket的内容最够小时，bucket.root中不再保存页ID而是置零，同时将bucket的所有数据按照正常以页保存方式进行序列化之后拼接在bucket.sequence之后，如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://xiaoqihai.oss-cn-shanghai.aliyuncs.com/img/20200412151142.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;b-1&#34;&gt;B+树的写时拷贝实现&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;注：这部分我们不介绍B+树在增加/删除节点的分裂/聚合这种重平衡（rebalance)的逻辑。这部分的逻辑和其他B+树无异，逻辑也不复杂，因此不再赘述。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;boltdb中对数据的所有操作都需要通过Cursor先定位数据在B+树中的位置，然后才能进行相关操作。而操作可分为读与写，写时拷贝指所有写操作必须发生在拷贝之上。我们再看看数据结构中和Cursor相关的部分&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://xiaoqihai.oss-cn-shanghai.aliyuncs.com/img/20200412161742.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Cursor&lt;/strong&gt;, 代表当前操作位置。更为具体的，字段stack保存了从根到当前位置的路径，因此&lt;code&gt;stack[len(stack)-1]&lt;/code&gt;, 即路径中最后一个元素为当前操作对象。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;elemRef&lt;/code&gt;&lt;/strong&gt; 表示B+树中一个元素（节点或叶子）所在的页及元素位置。既然这样，那&lt;code&gt;page&lt;/code&gt;结构体就足够了，为什么还需要&lt;code&gt;node&lt;/code&gt;结构体呢？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;node&lt;/code&gt;&lt;/strong&gt;结构体表示一个物理页反序列化之后在内存的表示。这里的内存指的是非mmap的空间。所有的改动都发生在&lt;code&gt;node&lt;/code&gt;之上，而&lt;code&gt;page&lt;/code&gt;只供读取。因为mmap使用的是&lt;code&gt;PROT_READ&lt;/code&gt;的保护策略，因此任何写&lt;code&gt;page&lt;/code&gt;的行为都将触发段错误，保证在实现写时拷贝逻辑的正确性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;inode&lt;/code&gt;&lt;/strong&gt; 当node节点为叶子节点时，其子节点（叶子）的内容用inode表示，这里也只包含修改过的inode。 &lt;strong&gt;当叶子类型为bucket时，pgid保存了其所在页ID&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;heading&#34;&gt;空闲页管理&lt;/h2&gt;
&lt;p&gt;空闲页的管理无非就是两个问题：识别脏页（空闲页）、回收（重用）脏页。&lt;/p&gt;
&lt;h3 id=&#34;heading-1&#34;&gt;怎么识别脏页（空闲页）&lt;/h3&gt;
&lt;p&gt;再看node 与 &lt;code&gt;inode&lt;/code&gt;结构体，都包含了其反序列化而来的原始页ID。而这些页在事务提交时也就变成了脏页（新版本数据会写到新页中），&lt;strong&gt;但这些脏页并不会立即释放而是放进freelist的等待队列中&lt;/strong&gt;。之所以不立即释放是因为这些页还可能被其他读事务在访问。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://xiaoqihai.oss-cn-shanghai.aliyuncs.com/img/20200412162002.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;heading-2&#34;&gt;怎么回收空闲页&lt;/h3&gt;
&lt;p&gt;前面提到了脏页可能不会立即释放，那么脏页什么时候释放呢？因为只有释放的脏页才能安全地进行重用。先看看freelist的数据结构，其不仅有已经完全释放的脏页（ids)，也有等待释放的事务极其对应的脏页列表（pending）。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// freelist represents a list of all pages that are available for allocation.
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// It also tracks pages that have been freed but are still in use by open transactions.
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;freelist&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;ids&lt;/span&gt;     &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;pgid&lt;/span&gt;          &lt;span class=&#34;c1&#34;&gt;// all free and available free page ids.
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;pending&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;map&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;txid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;pgid&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// mapping of soon-to-be free page ids by tx.
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;cache&lt;/span&gt;   &lt;span class=&#34;kd&#34;&gt;map&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;pgid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;bool&lt;/span&gt;   &lt;span class=&#34;c1&#34;&gt;// fast lookup of all free and pending page ids.
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;事务提交时，将其对应的脏页添列表加进freelist的等待队列集合中。而数据结构&lt;code&gt;DB&lt;/code&gt;中保存了所有正在进行中的事务ID。所有的写事务会递增ID，而读事务使用当前版本的ID（两个meta页中事务ID最大的一个）。因此，&lt;strong&gt;在创建新的写事物时，通过遍历DB中的所有事务，找出ID最小的minID, freelist的等待释放集合中任何小于minID的脏页列表都可以被安全释放&lt;/strong&gt;&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>boltdb源码解析（二）—— 数据结构与核心算法</title>
      <link>http://auntlei.com/post/source/boltdb_2/</link>
      <pubDate>Thu, 02 Apr 2020 17:05:20 +0800</pubDate>
      
      <guid>http://auntlei.com/post/source/boltdb_2/</guid>
      
        <description>&lt;p&gt;&lt;a href=&#34;http://auntlei.com/post/source/boltdb_1/&#34;&gt;boltdb源码解析（一）—— 简介&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;介绍blotdb的使用、优势与注意事项，以及源码组织结构。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://auntlei.com/post/source/boltdb_2/&#34;&gt;boltdb源码解析（二）—— 数据结构与核心算法&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;介绍核心数据结构，数据持久化到文件的物理布局，与核心算法介绍。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://auntlei.com/post/source/boltdb_3/&#34;&gt;boltdb源码解析（三）—— CURD实现细节&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;深入实现细节剖析CURD，及空闲页管理逻辑&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://auntlei.com/post/source/boltdb_4/&#34;&gt;boltdb源码解析（四）—— ACID特性论证&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;分析、证明boltdb是如何保证ACID的四个重要特性&lt;/p&gt;
&lt;h2 id=&#34;lmdb-&#34;&gt;LMDB 核心思想&lt;/h2&gt;
&lt;p&gt;boltdb源自于LMDB（&lt;a href=&#34;https://en.wikipedia.org/wiki/Lightning_Memory-Mapped_Database&#34;&gt;Lightning Memory-Mapped Database&lt;/a&gt;），基本可以视作LMDB的golang实现。虽然两者存在细微差别（最明显的，在功能上LMDB支持多进程共享同一数据库而blotdb不能），但这并不影响以LMDB的视角来理解boltdb。LMDB的核心思想非常简单：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;使用mmap映射整个数据库文件，利用文件系统和操作系统的缓存来规避复杂的缓存管理。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用写时拷贝（copy on write)的b+树来更新数据，保证数据永远不会处于损坏状态，不需要WAL（Write Ahead Logging)以及对相应的数据恢复过程。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;通过和其他数据库作对比，我们能更好地理解这两个简单设计的初衷与优势。&lt;/p&gt;
&lt;h3 id=&#34;heading&#34;&gt;性能（缓存）&lt;/h3&gt;
&lt;p&gt;影响性能有很多方面，这里只讨论缓存设计，对于读写竞争不做介绍。下文会介绍写时拷贝b+树，而写时拷贝自然而然也就实现了&lt;a href=&#34;https://en.wikipedia.org/wiki/Multiversion_concurrency_control&#34;&gt;MVCC（Multiversion concurrency control&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;Howard Chu（LMDB作者）介绍在设计LMDB之前，他和其他人一样使用著名的&lt;a href=&#34;https://en.wikipedia.org/wiki/Berkeley_DB&#34;&gt;Berkeley DB（BDB）&lt;/a&gt;。但是BDB有三层缓存系统，对这套复杂系统进行调优需要花很多时间，并且可能造成一些意想不到的结果，比如数据库死锁，而LMDB使用mmap则不需要额外的缓存系统就可以带来理想的性能收益，数据库配置也变得更加简单。这也是核心思想中的第1点。&lt;/p&gt;
&lt;p&gt;此外LMDB中mmap采用了只读方式，直接写内存中的数据会产生段错误（SEGV），这样的好处是在迭代开发的过程中，可以快速发现逻辑错误。那么怎么更新数据呢？blotdb采用的是直接写文件+fsync的方式。&lt;/p&gt;
&lt;h3 id=&#34;heading-1&#34;&gt;数据一致性&lt;/h3&gt;
&lt;p&gt;性能只是数据库设计的一方面，另一方面是对事务ACID特性的保证。LMDB使用写时拷贝B+树，在介绍它之前，我们可以先了解下其它技术。&lt;/p&gt;
&lt;h4 id=&#34;wal&#34;&gt;WAL&lt;/h4&gt;
&lt;p&gt;BDB及其他数据库多使用&lt;a href=&#34;https://en.wikipedia.org/wiki/Write-ahead_logging&#34;&gt;WAL&lt;/a&gt;来保证数据的一致性。WAL是指描述改动的操作记录必须先被持久化到磁盘上之后，才能修改对应的值并提交整个事务。当数据处于不一致的状态时（比如处理事务过程中宕机后重启），可以通过回扫操作记录将数据库恢复到一个一致的状态。&lt;/p&gt;
&lt;p&gt;下图描述了往一个空的key-value 数据库中&lt;code&gt;put(key-1,value-1)&lt;/code&gt;过程中WAL与数据修改之间的关系。注意这个只是概念演示，不同的数据库实现有不同的方式。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://xiaoqihai.oss-cn-shanghai.aliyuncs.com/img/20200410133805.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;bappend-only-b-tree&#34;&gt;只追加B+树（append-only B+ tree）&lt;/h4&gt;
&lt;p&gt;WAL的方式中数据和数据操作（日志）是分开的，而只追加B+树则不需要额外的日志。下面举例说明&lt;/p&gt;
&lt;p&gt;假设现有一个三层B+树组织的数据&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://xiaoqihai.oss-cn-shanghai.aliyuncs.com/img/20200410125417.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;其在磁盘上的布局是这样，其中块meta10是数据库的元信息所在。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://xiaoqihai.oss-cn-shanghai.aliyuncs.com/img/20200410125604.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;当需要修改块叶子节点8（leaf 8）上的数据时，我们并不直接在原始块上做修改，而是对其做一份拷贝，在拷贝上进行修改。修改后，树变成了这样&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://xiaoqihai.oss-cn-shanghai.aliyuncs.com/img/20200410130204.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;当然数据库的元信息也需要更新，并且更新也发生在拷贝之上。最后新增的内容都以追加的方式&lt;strong&gt;顺序写入磁盘&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://xiaoqihai.oss-cn-shanghai.aliyuncs.com/img/20200410130652.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;从上图可以看出，此时数据库中实际上存在两个版本的数据。这极大地提升了数据库的并发性能，也保证了所有事务都能看到某一个一致的视图（虽然版本可能不一样）。虽然写入数据变多，但是对机械硬盘而言，顺序写的性能远优于随机读写，整体上性能依旧很好。&lt;/p&gt;
&lt;p&gt;不过问题也很明显。如上所述，虽然我们仅仅需要修改块（leaf 8）的部分数据，我们最后却在磁盘上新增了4个块。如果我们不断地进行数据更新，那么最后数据库中将存在多个版本的内容，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://xiaoqihai.oss-cn-shanghai.aliyuncs.com/img/20200410131640.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;事实上，几乎所有的应用场景中，我们都不需要维护过多的版本，因此数据库实现通常会有后台线程对将来不会使用的数据（即版本小于所有运行中事务的最低版本）进行垃圾回收。而垃圾回收势必会来带空间碎片，在回收的过程中也伴随着重排。重排需要移动大量的数据，因此会在一定程度降低数据库的性能，甚至在回收时增加响应时间。&lt;/p&gt;
&lt;h4 id=&#34;blmdb&#34;&gt;写时拷贝B+树（LMDB方式）&lt;/h4&gt;
&lt;p&gt;其实上文中的只追加B+树也是写时拷贝，和这里提到的LMDB的写时拷贝的B+树区别在于，LMDB数据库中只维护两个版本的数据，因此在任意时刻也就只能有一个写操作。与只追加B+树一样，都可以有“无限”个读，并且读-读与读-写之间不会存在竞争。&lt;/p&gt;
&lt;p&gt;那么只维护两个版本有什么好处呢？&lt;/p&gt;
&lt;p&gt;好处就是省去了繁琐的垃圾回收避免了因为垃圾回收而带来的性能下降。LMDB的写时拷贝B+树会优先使用被标记为空闲的块，而不是分配新的块。如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://xiaoqihai.oss-cn-shanghai.aliyuncs.com/img/20200410133143.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;同样，因为写操作不可并发，因此LMDB并不是真正的“MV&amp;quot;CC&lt;/p&gt;
&lt;h2 id=&#34;boltdb&#34;&gt;boltdb实现&lt;/h2&gt;
&lt;p&gt;和LMDB实现一样，boltdb的代码量也很小(&amp;lt;3K LOC），很适合作为了解数据库实现的起点。下图描述了boltdb的所有数据结构。按照golang 的语言约束，我们可以将这些数据结构拆分成对外输出的数据结构和内部数据结构。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://xiaoqihai.oss-cn-shanghai.aliyuncs.com/img/20200412161542.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;注： 图中省略了很多不重要的字段，这些字段将在下文必要时进行补充说明。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对外输出的数据结构
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;DB&lt;/strong&gt; 指代单个数据库，对应一个数据文件&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Tx&lt;/strong&gt;（事务，transaction)，数据的所有操作都应该在事务中进行&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Bucket&lt;/strong&gt;（桶），boltdb组织数据的基本方式。数据可以放到不同的桶中，并且桶也可以作为值内敛到外层的桶中。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Cursor&lt;/strong&gt;（游标），对桶内数据的查看修改需要通过游标来进行定位。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;内部数据结构
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;meta&lt;/strong&gt; 数据库的元信息。每个meta信息实际上对应一个数据库版本，和LMDB一致，boltdb只有两个版本。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;bucket&lt;/strong&gt; 对外暴露结构Bucket的持久化版，包含了Bucket所处的物理页ID及当前自增序列值&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;freelist&lt;/strong&gt; blotdb中所有空闲以及即将空闲页的管理器。后文会详细具体介绍空闲也的管理方式&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;page&lt;/strong&gt; boltdb管理存储的基本单位。后文介绍数据持久化时会对page进行更为详细地介绍。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;elemRef&lt;/strong&gt; 表示Cursor当前定位的数据。数据可能是一个B+树的中间节点，也可能是叶子节点。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;node&lt;/strong&gt; 表示page在内存中反序列化的结果，表示B+树的中间节点。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;inode&lt;/strong&gt; 便是node节点为叶子类型，inode表示其叶子。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;heading-2&#34;&gt;数据持久化&lt;/h3&gt;
&lt;h4 id=&#34;heading-3&#34;&gt;数据结构&lt;/h4&gt;
&lt;p&gt;这里不包括B+树相关的持久化方式，此部分在后续介绍B+树管理数据部分会详细介绍。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;page（页）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;bolt管理文件数据的基本单位，单位大小等同于操作系统页大小。包含头部（header) 与数据区（data)两部分。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://xiaoqihai.oss-cn-shanghai.aliyuncs.com/img/20200410173920.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;id: 此页唯一标志，从0开始顺序递增&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;flags: 标记此页数据区存放的数据种类。有四种类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;meta: 数据库的元信息，整个数据库只有两张meta页，并且固定在文件的前两页&lt;/li&gt;
&lt;li&gt;freelist: 空闲页列表&lt;/li&gt;
&lt;li&gt;branch: b+ tree 中间节点&lt;/li&gt;
&lt;li&gt;leaf：b+ tree 叶子节点 。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;count: 当数据区的数据是一个列表时，表示其长度。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;overflow: 数据是否“溢出”当前页。其值N表示，此页物理后继的N页大小的数据也是此页的数据。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下图展示了页中overflow和id之间的关系。页2向后溢出两个单位，页3、4作为页2的溢出页将不包含页头而只包含数据内容。页5的ID顺序递增为5而不是3。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://xiaoqihai.oss-cn-shanghai.aliyuncs.com/img/20200410174229.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;meta（元信息）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;持久化时meta作为数据块写入元信息页中的数据区，页头中的flag标记位为0x4。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://xiaoqihai.oss-cn-shanghai.aliyuncs.com/img/20200410175332.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;注： 图中的字段名不完全是源代码中的名称，而是用语义更丰富准确的短语替代。看源代码时能很容易进行关联&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;magic、version 魔数和版本号&lt;/li&gt;
&lt;li&gt;page size  第一次数据持久化时操作系统的页大小。当从数据文件中恢复数据库时，boltdb需要知道以前的页大小才能正确地定位数据。&lt;/li&gt;
&lt;li&gt;flags   保留字段&lt;/li&gt;
&lt;li&gt;root   数据库最顶层的虚拟bucket。&lt;/li&gt;
&lt;li&gt;freelist  用于存放空闲页列表（freelist）的物理页ID&lt;/li&gt;
&lt;li&gt;max page id  此数据库可访问的最大页ID。主要用于检测逻辑错误，比如是否将数据写到了期望偏移之外。&lt;/li&gt;
&lt;li&gt;trasaction id 最新的写事务的ID。用于追踪数据库最新版本。&lt;/li&gt;
&lt;li&gt;checksum 以上字段的校验和。如果校验通过则可以确认当前meta page是一个正确的数据库元信息页，及其所指向的数据处于一致状态。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;bucket 的持久化结构如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://xiaoqihai.oss-cn-shanghai.aliyuncs.com/img/20200412144541.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;其中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;root 此bucket根节点所在的页ID&lt;/li&gt;
&lt;li&gt;sequence 用于实现单个bucket的自增序列&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;heading-4&#34;&gt;物理布局&lt;/h4&gt;
&lt;p&gt;其他使用只追加B+树的数据库，元信息页一般在文件的最后几个块，进行数据恢复时只需要从后完前找到第一个正确的元信息页就可以恢复整个数据库。&lt;/p&gt;
&lt;p&gt;而boltdb其两个元信息页位于文件的最开始两页。数据库启动（恢复时）只需要验证前两页就能恢复整个数据库。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://xiaoqihai.oss-cn-shanghai.aliyuncs.com/img/20200412112324.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;元信息页（meta page)作为数据库的入口，通过保存root bucket的页地址将数据的所有地址串联起来，而保存freelist page的页地址则将所有的空闲页串联起来。&lt;/p&gt;
&lt;h2 id=&#34;heading-5&#34;&gt;参考资料&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.infoq.com/presentations/lmdb-lighting-memory-mapped-database/#downloadPdf/&#34;&gt;Howard Chu 关于LMDB的演讲&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://www.bzero.se/ldapd/btree.html&#34;&gt;how the append-only btree works&lt;/a&gt;&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>boltdb源码解析（一）—— 简介</title>
      <link>http://auntlei.com/post/source/boltdb_1/</link>
      <pubDate>Thu, 02 Apr 2020 17:04:20 +0800</pubDate>
      
      <guid>http://auntlei.com/post/source/boltdb_1/</guid>
      
        <description>&lt;p&gt;&lt;a href=&#34;http://auntlei.com/post/source/boltdb_1/&#34;&gt;boltdb源码解析（一）—— 简介&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;介绍blotdb的使用，优势与注意事项，以及源码组织结构。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://auntlei.com/post/source/boltdb_2/&#34;&gt;boltdb源码解析（二）—— 数据结构与核心算法&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;介绍核心数据结构，数据持久化到文件的物理布局，与核心算法介绍。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://auntlei.com/post/source/boltdb_3/&#34;&gt;boltdb源码解析（三）—— CURD实现细节&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;深入实现细节剖析CURD，及空闲页管理逻辑&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://auntlei.com/post/source/boltdb_4/&#34;&gt;boltdb源码解析（四）—— ACID特性论证&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;分析、证明boltdb是如何保证ACID的四个重要特性&lt;/p&gt;
&lt;h2 id=&#34;boltdb-&#34;&gt;boltdb 简介&lt;/h2&gt;
&lt;h3 id=&#34;heading&#34;&gt;是什么&lt;/h3&gt;
&lt;p&gt;boltdb是纯golang实现的一个键-值数据库，你可以在自己的程序中使用boltdb库创建/操作数据库。boltdb参考LMDB实现，代码简洁也非常适合学习数据库的实现。boltdb的原始库已经归档，coreOS维护的fork用于社区开发者持续迭代。&lt;/p&gt;
&lt;h3 id=&#34;heading-1&#34;&gt;怎么使用&lt;/h3&gt;
&lt;p&gt;简单示例如下， 新建一个数据库文件&lt;code&gt;my.db&lt;/code&gt;、创建一个新桶&lt;code&gt;MyBucket&lt;/code&gt;， 并放入键值对： &lt;code&gt;&amp;quot;my-key&amp;quot;, &amp;quot;my-value&amp;quot;&lt;/code&gt;。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;  &lt;span class=&#34;c1&#34;&gt;// Open the my.db data file in your current directory.
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;c1&#34;&gt;// It will be created if it doesn&amp;#39;t exist.
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;db&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;bolt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Open&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;my.db&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mo&#34;&gt;0600&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;log&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Fatal&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;defer&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;db&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Close&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;

	&lt;span class=&#34;nx&#34;&gt;db&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Update&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;tx&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;bolt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Tx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;error&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;tx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;CreateBucket&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;byte&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;MyBucket&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
			&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Errorf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;create bucket: %s&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
		&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Put&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;byte&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;my-key&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;byte&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;my-value&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;更多的用法可以参考boltdb &lt;a href=&#34;https://github.com/boltdb/bolt#getting-started&#34;&gt;README&lt;/a&gt; 及godoc。&lt;/p&gt;
&lt;h3 id=&#34;heading-2&#34;&gt;适用场景&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;程序需要内嵌数据库&lt;/li&gt;
&lt;li&gt;只需要简单的键值存储，不需要复杂的SQL查询与处理&lt;/li&gt;
&lt;li&gt;数据读多于写&lt;/li&gt;
&lt;li&gt;需要事务保证&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有哪些项目使用了boltdb?&lt;/p&gt;
&lt;p&gt;比如&lt;a href=&#34;https://influxdata.com/&#34;&gt;InfluxDB&lt;/a&gt;，&lt;a href=&#34;https://github.com/hashicorp/consul&#34;&gt;Consul&lt;/a&gt;，&lt;a href=&#34;https://github.com/chrislusf/seaweedfs&#34;&gt;Seaweed File System&lt;/a&gt;。目前还没有时间探索这些知名项目是如何使用boltdb的。&lt;/p&gt;
&lt;h2 id=&#34;heading-3&#34;&gt;源码组织结构&lt;/h2&gt;
&lt;p&gt;只包含重要文件。golang通过编译标志支持多平台可以参考 &lt;a href=&#34;https://golang.org/pkg/go/build/&#34;&gt;go build&lt;/a&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;bolt_os_arch.go   // 含各操作系统、体系架构特殊syscall的实现
bucket.go					// 数据库桶操作及持久化相关代码
cursor.go					// 游标操作相关代码，用于定位读写位置
db.go							// 数据库最顶层抽象
freelist.go				// 空闲页管理逻辑
node.go						// b+树节点相关操作
page.go						// 物理页相关操作
tx.go							// 事务相关操作
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;</description>
      
    </item>
    
    <item>
      <title>golang新手可能踩的坑</title>
      <link>http://auntlei.com/post/golang/more-effective-go/</link>
      <pubDate>Mon, 30 Mar 2020 22:17:34 +0800</pubDate>
      
      <guid>http://auntlei.com/post/golang/more-effective-go/</guid>
      
        <description>&lt;p&gt;写出地道的golang风格的代码，官方文档&lt;a href=&#34;https://golang.org/doc/effective_go.html#pointers_vs_values&#34;&gt;Effective GO&lt;/a&gt;、&lt;a href=&#34;https://github.com/golang/go/wiki/CodeReviewComments&#34;&gt;Go Code Review Comments&lt;/a&gt;介绍得很详细，而且很多大厂也有自己内部的风格，在这里就不一一赘述。本文只关注可能引入bug或者性能下降的错误写法，及一些最佳实践。为方便查看，每个tip作为一个小标题单独列出。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;虽然不涵盖编程风格，但是强烈建议读者使用gofmt，并且打开IDE的lint功能，多次按照lint提示修改代码之后，最终自然而然就会写出符合golang风格的代码&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;defer&#34;&gt;defer&lt;/h2&gt;
&lt;h3 id=&#34;defer-lifodefer&#34;&gt;defer 执行循序为LIFO，参数的值在defer语句执行时就已经确定。&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;defer&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;%d &amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;输出&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;4 3 2 1 0 
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;deldefer--defer-mutexunlock-mutexunlockdel&#34;&gt;&lt;!-- raw HTML omitted --&gt;defer 并不是免费的。比如 defer Mutex.Unlock 比直接Mutex.Unlock开销更大&lt;!-- raw HTML omitted --&gt;&lt;/h3&gt;
&lt;p&gt;对于一些简短的加锁-修改某个值-释放锁的操作可以做么做。但是如果在加锁之后，可能在不同的分支都需要执行释放锁，还是建议直接使用defer Mutex.Unlock， 否则在（以后）修改或者新增分支的时候可能忘记释放锁从而引入bug。除非必要，应该&lt;strong&gt;以代码的可维护性为主&lt;/strong&gt;。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;unlockDefer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;l&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;sync&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Mutex&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Lock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;rand&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;defer&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Unlock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;unlockDirect&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;l&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;sync&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Mutex&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Lock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;rand&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Unlock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;BenchmarkUnlockDefer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;b&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;testing&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;B&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;l&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;sync&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Mutex&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;N&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nf&#34;&gt;unlockDefer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;BenchmarkUnlockDirect&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;b&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;testing&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;B&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;l&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;sync&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Mutex&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;N&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nf&#34;&gt;unlockDirect&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;BenchmarkUnlockDefer-4          20000000                56.9 ns/op
BenchmarkUnlockDirect-4         50000000                31.7 ns/op
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;slice-vs-array&#34;&gt;slice vs array&lt;/h2&gt;
&lt;h3 id=&#34;array&#34;&gt;array的长度是类型的一部分&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;[3]int&lt;/code&gt; 和 &lt;code&gt;[4]int&lt;/code&gt; 是不同的类型&lt;/p&gt;
&lt;h3 id=&#34;array-&#34;&gt;array 是传值的，值指的是整个数组的内容&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;9
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;modify&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;...&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;nf&#34;&gt;modify&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;输出&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;[3 2 1]
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;slice-&#34;&gt;slice 本质也是传值，但看起来像传递了底层数组的引用&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;golang 都是传值的&lt;/strong&gt;，slice看起来像是传引用是因为slice的值本身包含了一个对底层数组的引用（指针）。通过查看下面的slice结构体描述就很清晰。&lt;a href=&#34;https://golang.org/src/runtime/slice.go&#34;&gt;src/runtime/slice.go&lt;/a&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;type slice struct {
	array unsafe.Pointer
	len   int
	cap   int
}
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;slice-mapkeyslicearray&#34;&gt;slice 不能作为map对象的key，因为slice没有实现完全实现&lt;code&gt;==&lt;/code&gt;操作符，但是array可以。&lt;/h3&gt;
&lt;p&gt;slice 只能使用&lt;code&gt;==&lt;/code&gt; 判断是否为nil。&lt;/p&gt;
&lt;h2 id=&#34;slice--1&#34;&gt;slice 与内存模型&lt;/h2&gt;
&lt;h3 id=&#34;append-&#34;&gt;append 不是线程安全的&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;s&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;
	&lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;wg&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;sync&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;WaitGroup&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;wg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Add&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;go&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
			&lt;span class=&#34;nx&#34;&gt;s&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;append&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
			&lt;span class=&#34;nx&#34;&gt;wg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Done&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
		&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;wg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Wait&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;一种可能的输出：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;[0 6 7 9]
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;axbyabsliceaxby&#34;&gt;a[x]与b[y]是否存在竟态，与a、b是否为同一slice无关，只与a[x]与b[y]是否指向同一块内存区域有关&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://golang.org/ref/spec#Variables&#34;&gt;golang language specification中关于variables的介绍&lt;/a&gt; 中有这样一句话&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;Structured&lt;/em&gt; variables of &lt;a href=&#34;https://golang.org/ref/spec#Array_types&#34;&gt;array&lt;/a&gt;, &lt;a href=&#34;https://golang.org/ref/spec#Slice_types&#34;&gt;slice&lt;/a&gt;, and &lt;a href=&#34;https://golang.org/ref/spec#Struct_types&#34;&gt;struct&lt;/a&gt; types have elements and fields that may be &lt;a href=&#34;https://golang.org/ref/spec#Address_operators&#34;&gt;addressed&lt;/a&gt; individually. Each such element acts like a variable.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;也就是说对于slice s而言，我们应该将s[i]看做是一个独立的变量（variable)。&lt;/p&gt;
&lt;p&gt;例如，对于下面这段代码，虽然a、b是两个完全不同是slice，但是a[1]与b[0]指向了同一块内存区域，等同于同一个变量。如果对a[1]与b[0]的并发访问不做可见性保护（如加锁），那么可能在代码中出现并发bug。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;b&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;go&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;go run -race ./
2
==================
WARNING: DATA RACE
Write at 0x00c0000a2008 by goroutine 6:
  main.main.func1()
      /Users/vicxiao/workspace/go/test/main.go:11 +0x47

Previous read at 0x00c0000a2008 by main goroutine:
  main.main()
      /Users/vicxiao/workspace/go/test/main.go:13 +0xaa

Goroutine 6 (running) created at:
  main.main()
      /Users/vicxiao/workspace/go/test/main.go:10 +0x98
==================
Found 1 data race(s)
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;如果将第5行&lt;code&gt;a[1]=0&lt;/code&gt; 替换为&lt;code&gt;a[0]=0&lt;/code&gt;，那么因为a[0]与b[0]指向的是不同内存区域，就不会有竟态发生。&lt;/p&gt;
&lt;h2 id=&#34;byte&#34;&gt;与[]byte相关的性能问题&lt;/h2&gt;
&lt;h3 id=&#34;slice-gc&#34;&gt;slice 引用底层数组而造成内存泄露/GC压力&lt;/h3&gt;
&lt;p&gt;例如，使用&lt;code&gt;ioutil.ReadAll&lt;/code&gt;读取了一个10M的文件，并将其前512K切片为另外一个slice b使用。只要b还被引用，那么其指向的底层数组也不会被释放。&lt;/p&gt;
&lt;h3 id=&#34;copyappend&#34;&gt;复制数据时使用copy比append性能更优&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;
	&lt;span class=&#34;s&#34;&gt;&amp;#34;crypto/rand&amp;#34;&lt;/span&gt;
	&lt;span class=&#34;s&#34;&gt;&amp;#34;testing&amp;#34;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;src&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;make&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;byte&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;512&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;dst&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;make&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;byte&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;512&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;genSource&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;rand&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Read&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;src&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;BenchmarkCopy&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;b&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;testing&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;B&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;N&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;StopTimer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
		&lt;span class=&#34;nf&#34;&gt;genSource&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;StartTimer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
		&lt;span class=&#34;nb&#34;&gt;copy&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;dst&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;src&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;BenchmarkAppend&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;b&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;testing&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;B&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;N&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;StopTimer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
		&lt;span class=&#34;nf&#34;&gt;genSource&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;StartTimer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;dst&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;append&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;dst&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;src&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;...&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;注：&lt;/p&gt;
&lt;p&gt;dst作为全局变量是防止编译器优化for-loop&lt;/p&gt;
&lt;p&gt;测试时，机器不繁忙&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;9
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;uptime;go version;go test -bench=. ./
 11:56:10 up 294 days, 14:58,  3 users,  load average: 0.58, 0.52, 0.63
go version go1.14.1 linux/amd64
goos: linux
goarch: amd64
pkg: copyvsappend
BenchmarkCopy-40      	 9808320	       116 ns/op
BenchmarkAppend-40    	  479055	      8740 ns/op
PASS
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;readerreadfullioutilreadall&#34;&gt;如果知道Reader里的数据大小，使用&lt;code&gt;ReadFull&lt;/code&gt;而不是&lt;code&gt;ioutil.ReadAll&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;常见的场景如读取HTTP body。如果HTTP header中包含了&lt;code&gt;Content-Length&lt;/code&gt;那么我们先申请足够大小的内存，然后调用一次&lt;code&gt;io.ReadFull&lt;/code&gt; 是最佳的选择。如果我们使用&lt;code&gt;ioutil.ReadAll&lt;/code&gt; 则会发生多次不必要的内存申请和内存拷贝。因为&lt;code&gt;ReadAll&lt;/code&gt; 是以一个较小的buffer开始，不断地循环调用&lt;code&gt;ReadFull&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id=&#34;channel&#34;&gt;channel&lt;/h2&gt;
&lt;h3 id=&#34;groutine-channelsyncmutex&#34;&gt;当竞争很激烈时(groutine 大几千)，同样能保证线程安全，但是channel的性能会比sync.Mutex好？&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://stackoverflow.com/questions/57562606/why-does-sync-mutex-largely-drop-performance-when-goroutine-contention-is-more-t&#34;&gt;https://stackoverflow.com/questions/57562606/why-does-sync-mutex-largely-drop-performance-when-goroutine-contention-is-more-t&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;for-range&#34;&gt;for range&lt;/h2&gt;
&lt;h3 id=&#34;range-&#34;&gt;如果每个元素比较大，循环时使用range 取值的方式遍历，性能较差&lt;/h3&gt;
&lt;p&gt;这个比较直观，因为有很多内存拷贝&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;X&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;15&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
   &lt;span class=&#34;nx&#34;&gt;val&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;
   &lt;span class=&#34;nx&#34;&gt;_&lt;/span&gt;   &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;4096&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;byte&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Result&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;BenchmarkRangeIndex&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;b&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;testing&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;B&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
   &lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;r&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;
   &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;N&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
      &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;range&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;X&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
         &lt;span class=&#34;nx&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;X&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
         &lt;span class=&#34;nx&#34;&gt;r&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;val&lt;/span&gt;
      &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
   &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
   &lt;span class=&#34;nx&#34;&gt;Result&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;r&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;BenchmarkRangeValue&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;b&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;testing&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;B&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
   &lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;r&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;
   &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;N&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
      &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;_&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;range&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;X&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
         &lt;span class=&#34;nx&#34;&gt;r&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;val&lt;/span&gt;
      &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
   &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
   &lt;span class=&#34;nx&#34;&gt;Result&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;r&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;BenchmarkFor&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;b&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;testing&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;B&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
   &lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;r&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;
   &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;N&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
      &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;len&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;X&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
         &lt;span class=&#34;nx&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;X&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
         &lt;span class=&#34;nx&#34;&gt;r&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;val&lt;/span&gt;
      &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
   &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
   &lt;span class=&#34;nx&#34;&gt;Result&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;r&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;BenchmarkRangeIndex-4              10000            127986 ns/op
BenchmarkRangeValue-4                 50          25939345 ns/op
BenchmarkFor-4                     10000            127817 ns/op
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;embeding&#34;&gt;embeding&lt;/h2&gt;
&lt;h3 id=&#34;stttss&#34;&gt;如果类型S内嵌了T，如果T定义函数接受者都是&lt;code&gt;*T&lt;/code&gt;类型，那么S定义的函数也应该以&lt;code&gt;*S&lt;/code&gt;为接受者为佳&lt;/h3&gt;
&lt;p&gt;这个主要是防止引入bug，例如下面的并发控制器，错误地在外层将接受者定义为值类型。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;type ConcurrentLocker struct{
	sync.Map
}

type LeaveFunc func()

func (cl ConcurrentLocker) Enter(key string) (bool, LeaveFunc) {
	if _, occupied := cl.LoadOrStore(key, struct{}{}); !occupied {
		return true, func(){
			cl.Delete(key)
		}
	}
	return false, nil
}

func main() {
	cl := ConcurrentLocker{}
	key := &amp;#34;some-key&amp;#34;
	fmt.Println(cl.Enter(key))
	fmt.Println(cl.Enter(key))
}
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;$ go run ./
true 0x10939e0
true 0x10939e0
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;当然修复的办法可以是内嵌&lt;code&gt;* sync.Map&lt;/code&gt;, 但是这样初始化的时候不够优雅，还需要单独初始化内部的map指针。我个人更倾向于与将&lt;code&gt;Enter&lt;/code&gt; 的接受者申明为&lt;code&gt;* ConcurrentLocker&lt;/code&gt;, 这样既逻辑正确，其作为整体暴露的函数的接受者也统一。&lt;/p&gt;
&lt;h2 id=&#34;interface&#34;&gt;interface&lt;/h2&gt;
&lt;h3 id=&#34;nilnil&#34;&gt;动态值为nil的接口值不为nil&lt;/h3&gt;
&lt;p&gt;这句话有点绕，看个示例就清晰了。猜猜下面的代码会打印什么&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;b&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;bytes&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Buffer&lt;/span&gt;
	&lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;w&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;io&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Writer&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;w&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;b&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;w&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;w is nil&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;w is NOT nil&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;答案：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;w is NOT nil
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;接口值，我们可以理解成一个二元组（动态类型、动态值）。在这个示例中w的类型为接口io.Writer，因为&lt;em&gt;bytes.Buffer 实现了Writer的所有接口，所以可以将b赋值给w。代码&lt;code&gt;var w io.Writer&lt;/code&gt;执行后，w还是一个零值，即其动态类型、动态值都为空。但是执行到&lt;code&gt;w = b&lt;/code&gt;之后，w的动态类型变为&lt;/em&gt;bytes.Buffer，而动态值为nil，即（*types.Buffer, nil)。因此w 不再是一个零值（nil)&lt;/p&gt;
&lt;p&gt;单独看这个例子，你可能觉得很简单不会犯错误。但是在实际的生产代码中，我们可能会写很多函数，其参数接受一个接口，为了防止panic，我们会对参数进行nil判断。但是因为调用方分散在各处，我们很有可能传递一个接口值不为nil但是动态值为nil的参数，如果这个参数它正好能处理接受者（receiver)为nil的情况，这就可能导致我们的函数不会panic，但是也不会正常运行，变成一个藏得很深的bug。&lt;/p&gt;
&lt;h2 id=&#34;heading&#34;&gt;参考资料&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://golang.org/doc/effective_go.html&#34;&gt;https://golang.org/doc/effective_go.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://golang.org/ref/mem&#34;&gt;https://golang.org/ref/mem&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://golang.org/ref/spec&#34;&gt;https://golang.org/ref/spec&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://dave.cheney.net/high-performance-go-workshop/gophercon-2019.html&#34;&gt;https://dave.cheney.net/high-performance-go-workshop/gophercon-2019.html&lt;/a&gt;&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>《事实》--实事求是地认识世界</title>
      <link>http://auntlei.com/post/reading/factness/</link>
      <pubDate>Wed, 11 Mar 2020 21:05:17 +0800</pubDate>
      
      <guid>http://auntlei.com/post/reading/factness/</guid>
      
        <description>&lt;p&gt;年初国内爆发了新型冠状病毒，各类自媒体也借此获得了不少流量。他们其中既有天下兴亡匹夫有责的义士、也不乏靠宣传骇人听闻的事件来激发人类最原始的恐惧从而增加自己公众号曝光的奸诈之徒。在一篇新冠病毒科普文章中，作者推荐了汉斯的这本《事实》。今天，我终于在工作之余拜读完这本注定对我世界观产生重大影响的著作。&lt;/p&gt;
&lt;p&gt;《事实》总结了人们认识世界时的十大误区：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;一分为二&lt;/p&gt;
&lt;p&gt;很多事物不是只有两个极端划分。比如，世界上不只是穷人和富人这两种截然对立的划分。人数最多的是中等收入群体。这点对于工科生比较好理解，想象一下正态分布的图形就可以了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;负面思维&lt;/p&gt;
&lt;p&gt;媒体总是报到负面的事件，因为这些事件才具有新闻报到的价值，才能吸引读者，才能在同行竞争中生存。但是我们更应该注意到，虽然世界上还有很多糟糕的时不时发生，但是世界整体是朝着更好的方向发展，在波动中上升。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;直线思维&lt;/p&gt;
&lt;p&gt;很多事情的发展规律不是直线。比如传染病，是一种指数函数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;恐惧本能&lt;/p&gt;
&lt;p&gt;总是担心最坏的事情。其实这个和理财类似，买彩票虽然在最好的情况下收益巨大，但是期望收益为负。很多人很奇怪，对于低概率的事件，如果事件本身是一件好事，他会觉得不可能发生在自己身上；但是如果这是一件很差很危险很可怕的事，他就表现的像一定会发生样。“过度关注可怕的而不是危险的事情，就意味着我们把自己宝贵的注意力放在了错误的方向。”&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;规模错觉&lt;/p&gt;
&lt;p&gt;二八原则。少数人/事会占据绝大部分的资源。我们应该着眼于优化这些资源占比高的项目。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;以偏概全&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;命中注定&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;单一视角&lt;/p&gt;
&lt;p&gt;评价一个事务关关注事务的全貌，而不是个别细枝末节。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;归咎他人&lt;/p&gt;
&lt;p&gt;要从本质上分析原因，而不是快速地将错误归咎于某人，某组织。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;情急生乱&lt;/p&gt;
&lt;p&gt;这点极其重要，人在情急的时候会产生两种本能反应：要么瞎选，要么放弃思考。其实很多事情不是想象中那么急，事情也不是简单的一分为二非好即坏。&lt;strong&gt;情况再紧急，我们也要基于数据做分析，最重要的是永远不能放弃思考&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;书中有很多详细地解释和例子，希望有缘读到这篇笔记的朋友一定抽空读读这本《事实》。&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>我的基金定投计划</title>
      <link>http://auntlei.com/post/misc/etf/</link>
      <pubDate>Mon, 20 Jan 2020 07:12:29 +0800</pubDate>
      
      <guid>http://auntlei.com/post/misc/etf/</guid>
      
        <description>&lt;h2 id=&#34;heading&#34;&gt;为什么要做定投？&lt;/h2&gt;
&lt;p&gt;我目前投资方式比较简单，基本上以招商银行的定期理财为主，年化收益率&lt;strong&gt;接近4%&lt;/strong&gt;，剩余部分则是一些T+0或者T+1的货币基金，比如支付宝，收益更低&lt;strong&gt;不到3%&lt;/strong&gt;。而&lt;a href=&#34;https://www.ceicdata.com/zh-hans/indicator/china/consumer-price-index-cpi-growth&#34;&gt;2019-12 CPI已经高到4.5%&lt;/a&gt;，跑输了通胀。 决定要参入到股市之中，承担市场经济发展的风险，也享受相等的回报。之前短暂的做过短线，赶上大盘整体回升，收益还不错，也明显跑赢了大盘，但是需要的精力太多，目前看来没有足够的精力继续操作短线。想参入股市，那我目前的选择只能是投资基金。基金做短线，收益不大，因为我只参与指数基金，而指数基金的短期振幅不会很大，没有盈利空间。如果花时间挑选一些其它板块、主题的基金，找出振幅大的，那还不如花时间做个股的短线。综上我决定定投指数基金，作为一种长期的理财方式。&lt;/p&gt;
&lt;h2 id=&#34;heading-1&#34;&gt;场内基金还是场外基金？&lt;/h2&gt;
&lt;p&gt;为方便比较，找一个常见的沪深300类的场外基金做对比。&lt;/p&gt;
&lt;p&gt;天弘沪深300ETF链接C， 买入费率0，管理费0.5%（每年），托管费0.1%（每年），销售服务费0.2%（每年），持有天数&amp;gt;7日则卖出费率为0，那么持有1年，3年，5年的大致费率为，0.8%，2.4%， 4%。&lt;/p&gt;
&lt;p&gt;如果我们直接购买300ETF，假设每次定投金额小于1万，则收取5元的佣金（ETF只收取佣金，没有印花税、过户费之类），如果是1000元的ETF， 那么持有1年、3年、5年的费率大致为， 1%, 1%, 1%。如果一次购买约2000的ETF， 则费率降低至0.5%， 0.5%， 0.5%。&lt;/p&gt;
&lt;p&gt;从上面的对比中可以看出&lt;strong&gt;直接购买ETF有明显的费率优势，这种优势会随着持有时间的增加和投资金额的增大而愈发明显&lt;/strong&gt;。既然我打算长期定投，那我肯定&lt;strong&gt;选择ETF&lt;/strong&gt;了。当然由于像股票一样，ETF的买卖单位是100份的整数倍，操作起来相对会麻烦一点。&lt;/p&gt;
&lt;h2 id=&#34;heading-2&#34;&gt;定投方式与金额&lt;/h2&gt;
&lt;p&gt;由于时间精力有限，并且计划长期定投，所以我决定只关注300ETF和500ETF。既然是投资，那么一定不能囫囵吞枣，更不能道听途说，一定要想明白什么情况下能赚钱，什么情况下亏损的可能性大。&lt;/p&gt;
&lt;p&gt;投资赚钱的本质是&lt;strong&gt;低买高卖&lt;/strong&gt;。实际操作中的难点在于未来的不确定性。高和低是相对概念，没有绝对值可以参考，因为未来的不确定性、低买高卖就是一种博弈。是期望值和实际值之间的博弈，是一种赌博。&lt;/p&gt;
&lt;h3 id=&#34;heading-3&#34;&gt;定投是怎么运作的，怎么选择定投目标，什么时候卖出？&lt;/h3&gt;
&lt;p&gt;定投最根本的假设是，&lt;strong&gt;市场是波动的&lt;/strong&gt;。通过定时定额（投资金额）的投资投资方式，在市价低时候多买入，而在市价高少买入，从而在整体上降低持仓成本，降低亏损的风险，当然利益相对最优解也会变少。&lt;strong&gt;可以这么理解，市场的振幅越大，定投的收益空间越大&lt;/strong&gt;。这个很好理解，如果市场毫无波澜，那么定投根本没有盈利空间，反而会亏损手续费，另外只要收益率低于银行定期存款的其实都是亏损。反之，假设市场是波动的，举个比较简单的具体例子，假设市价按照1、2、1、2这样周期性波动，那么定投的持仓成本就接近于1.5，只要市场保持波动，那么我们就有在市价为2的时候出手的机会，也就有盈利的机会。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;市场必然是波动的&lt;/strong&gt;，只要我们有耐心（对定投的这笔资金流动性要求不高），我们就能等到卖出价高于持仓成本的时机。当然这个前提你选的基本不能在你的投资周期内整体上程明显的下跌趋势。我们需要一个&lt;strong&gt;具有周期性&lt;/strong&gt;的基金来做定投，而指数基金就是一个不错的选择。&lt;em&gt;TODO：有空我会花的时间研究下其它的基金，说不定有同样具有稳定周期，但是周期性更短的基金&lt;/em&gt;。&lt;/p&gt;
&lt;h3 id=&#34;heading-4&#34;&gt;上证综合指数变化&lt;/h3&gt;
&lt;p&gt;从2001年初到2019年底之间，出现了两个牛市。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://xiaoqihai.oss-cn-shanghai.aliyuncs.com/img/20200116133847.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;再看近几年，最高点在2015.06 为5178。这波牛市持续了半年，成交量大市场活跃。之后跳水，从2016.01至今没有太大波澜。2019年年初市场活跃了一波。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://xiaoqihai.oss-cn-shanghai.aliyuncs.com/img/20200116134935.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;如果我们假设再过3年，能再一次达到5000点的顶峰，如果持仓成本4000，那么年化8%左右。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;以上证综合指数为参考，我们观察下300ETF，和500ETF&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;300ETF&lt;/strong&gt;，处于较危险的高位。如果三年内从4.0 升到5.0，持仓成本按照4.5计算的话，那么收益率为3.7%左右。照这样的估算方式，似乎没有太盈利空间。&lt;strong&gt;目前计划 3.7 以下才做买入&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://xiaoqihai.oss-cn-shanghai.aliyuncs.com/img/20200119132608.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;500ETF&lt;/strong&gt;，似乎还很有空间。如果三年内从6.0升到9.0，持仓成本按照7.5计算的话，那么收益率为6.7%左右。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://xiaoqihai.oss-cn-shanghai.aliyuncs.com/img/20200119132735.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;heading-5&#34;&gt;综上、具体操作方式&lt;/h3&gt;
&lt;h4 id=&#34;heading-6&#34;&gt;买入&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;定投时间为发放工资的下个交易日&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;以500ETF为主，2k左右做“定投”。正常情况以成交价&amp;lt;=2k为界（基本上就是3手），如果价格低于5.8则买4手（稍大于2K）。 平时（非定投范围）如果遇到&amp;lt;5的情况，时情况加仓1~2手。
&lt;img src=&#34;https://xiaoqihai.oss-cn-shanghai.aliyuncs.com/img/20200119134608.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;300ETF不做定投，按月观察，如果市价＜3.7 （理想情况&amp;lt;3.5）视情况买入3手，单月最多投资一次。&lt;/p&gt;
&lt;h4 id=&#34;heading-7&#34;&gt;卖出&lt;/h4&gt;
&lt;p&gt;由于市场周期性的存在，我们需要在一个合适时间点将基金卖出，从而尽可能的实现利益最大化。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;300ETF&lt;/strong&gt;4.3是一个参考点。&lt;br&gt;
&lt;strong&gt;500ETF&lt;/strong&gt;7.0， 8.0，9.0 三个参考点，要求年化&amp;gt;10%&lt;br&gt;
&lt;img src=&#34;https://xiaoqihai.oss-cn-shanghai.aliyuncs.com/img/20200120073806.png&#34; alt=&#34;&#34;&gt;
&lt;strong&gt;调整心态，不求最优解&lt;/strong&gt;&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>活出生命的意义</title>
      <link>http://auntlei.com/post/reading/meaning_of_life/</link>
      <pubDate>Sun, 12 Jan 2020 17:04:39 +0800</pubDate>
      
      <guid>http://auntlei.com/post/reading/meaning_of_life/</guid>
      
        <description>&lt;p&gt;前阵子从同事那买入了一个二手kindle，我那模糊的愿望单里又划掉了一条项目，内心喜悦溢于言表。这是继ipad，mac之后又一个读书时的“奢望”被满足，当然高兴！本着物尽其用的朴素思想，也趁着这新入手的高兴劲，装一个读书人。这一口气便读了三本书。&lt;/p&gt;
&lt;p&gt;《活着》，简简单单两个字是书名也是对整本书最好的概括。主人翁福贵出生地主家庭，是典型的纨绔子弟，不学无术、噬赌成命，终于败光所有家业一贫如洗。人在遭遇这种大变故时，都容易产生轻生的想法。不过想法归想法，很多人还是选择“活着”。福贵也活着面对接下来的清苦生活，也面对了后来命运对他的一切捉弄——出门给病危的老娘买药却被抓壮丁，好不容易从战场活着回来，可是老娘已经去世大女儿也因为一场意外变成了聋哑人。到后来的大饥荒、大跃进、以及文化大革命，命运持续不断地捉弄着这个苦命人，最后落得孤家寡人一枚。活着是福贵最朴素的思想，支撑他承受着命运的酸甜苦辣。但是人不应该只是“活着”，而是应该活出生命的意义。&lt;/p&gt;
&lt;p&gt;《活出生命的意义》是弗兰克尔对生命的思考，这种思考最终帮助他从纳粹集中营幸存下来。这本书不是一部文学作品，而是一部心理学作品。书的前半部分是对自己在集中营经历的描述，在描述的过程中阐述自己的的心里学观点。而后半部分则是对意义疗法的总结和实践指导。想帮助一个人活下去，就帮助他找到生命的意义，这个意义可以很简单，就是一个简单的责任，比如许三观对家庭的责任。&lt;/p&gt;
&lt;p&gt;看了余华的《活着》觉得意犹未尽，于是又拜读了他的另一部经典著作，《许三观卖血记》。与《活着》充满了生活的沉重感不同，《许三观卖血记》在艰苦中透露着希望。当生活中有迈不过去的砍时，总是可以通过卖血这一离谱的生意来渡过。卖血之所以离谱是因为一次卖血35块钱，已经超过了一户农民一年的所得。这钱来得太容易，就好比摇钱树一般，但实际上确实用命在赌博。第一次读到许三观去卖血，我就担心他会染上严重的传染病，可许三观是幸运的。这使得读这本书的时候轻松不少。许三观是刀子嘴、豆腐心，在邻里有难之时还是愿意帮忙。不过虽然帮忙、但是嘴上依旧咄咄逼人、这些描写十分有趣。&lt;/p&gt;
&lt;p&gt;虽然有了kindle，可是我也快而立之年了，生命的意义当然不是拥有一个kindle、或者其它新奇的电子产品。那生命的意义是什么？娶妻生子、传宗接代？这些可以是人生路上的必经路，但是不应该是朝着终点行进的动力源泉。我还不知道人生的意义，但是有一点是明确的，我必须自己做选择，然后承担后果。我一定要保持自己的精神自由，选择自己的性格，自己的道德，哪怕处于何种苦痛和压迫之中。物质能影响选择的难度，但不能决定选择的结果。最简单地，当我快控制不住自己的脾气时，当我内心产生冲动时，一定要想想这是我想象中的我应有的行为吗？人活着如果不思考，不规划，只是被环境驱使，那就和羊群中的羊没有区别，生存的意义也不再属于自己。&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>经典论文导读系列之：facebook haystack</title>
      <link>http://auntlei.com/post/paper/haystack/</link>
      <pubDate>Sun, 29 Dec 2019 21:05:45 +0800</pubDate>
      
      <guid>http://auntlei.com/post/paper/haystack/</guid>
      
        <description>&lt;p&gt;facebook 09年发表的存储系统haystack，主要是优化海量小文件（图片）的访问效率，其核心思想是减少定位文件inode所需要的磁盘操作。通过回顾文件访问的相关的基础知识，我们也就能理解haystack的动机，以及之所以能提升性能的根本原因。&lt;/p&gt;
&lt;h2 id=&#34;heading&#34;&gt;基础知识回顾&lt;/h2&gt;
&lt;p&gt;在介绍linux文件系统之前，有必要简单回顾一下HDD，haystack论文的性能测试也是在HDD之上进行。SSD相对HDD最显著的提升是随机访问性能的质变，SSD的成本越来越低，容量也越来越大，但是目前HDD的价格优势依旧明显，在企业存储中仍占据主要地位。&lt;/p&gt;
&lt;h3 id=&#34;hdd&#34;&gt;机械磁盘HDD&lt;/h3&gt;
&lt;p&gt;选择性地忽略磁盘的一些无关硬件细节（比如远近圆心扇区存储介质密度差异）而只关注影响应用开发的抽象逻辑。那么，如&lt;a href=&#34;&#34;&gt;下图&lt;/a&gt;所示，机械磁盘主要包含一组“共进退”的机械臂和若干双面的碟片组成。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://xiaoqihai.oss-cn-shanghai.aliyuncs.com/img/20191229232729.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;更为简化地，我们实际只需要关注如下图中概念。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://xiaoqihai.oss-cn-shanghai.aliyuncs.com/img/20191229235404.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;特意画出&lt;strong&gt;机械臂&lt;/strong&gt;是为了强调移动是缓慢的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;扇区（Sector），磁盘I/O的最小单位，驱动程序对磁盘的读写操作都是读写一整个扇区，驱动程序能保证对整个扇区操作的原子性。过去512Byte的扇区比较常见，但是现在4K大小的扇区逐渐成为主流（4k也是常规linux一个页的大小）。而一条磁道（track）上有许多扇区。&lt;/p&gt;
&lt;p&gt;影响磁盘读写速度的主要有两个因素：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;寻道+寻址时间，移动机械臂使磁头位于对应磁道之上再转动碟片使得磁头位于对应扇区上的时间。&lt;/li&gt;
&lt;li&gt;读写速度。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;可以从&lt;a href=&#34;https://gist.github.com/jboner/2841832&#34;&gt;下表&lt;/a&gt;中大致知道HDD的性能与其它存储介质的差距。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;Latency Comparison Numbers (~2012)
--------------------------
Main memory reference                      100   ns
Send 1 KB bytes over 1 Gbps network     10,000   ns       10 us
Read 4 KB randomly from SSD*           150,000   ns      150 us          ~1GB/sec SSD
Read 1 MB sequentially from memory     250,000   ns      250 us
Read 1 MB sequentially from SSD*     1,000,000   ns    1,000 us    1 ms  ~1GB/sec SSD, 4X memory
Disk seek                           10,000,000   ns   10,000 us   10 ms 
Read 1 MB sequentially from 1 Gbps  10,000,000   ns   10,000 us   10 ms  40x memory, 10X SSD
Read 1 MB sequentially from disk    30,000,000   ns   30,000 us   30 ms 120x memory, 30X SSD
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;寻址（含寻道）时间10ms，而连续读取1MB（以512B算，2K个扇区）的数据却只需要30ms。&lt;strong&gt;机械磁盘的平均寻道时间是不可忽略的&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;linux&#34;&gt;Linux文件系统与文件查找&lt;/h3&gt;
&lt;p&gt;提及Linux文件系统，必然绕不开VFS（Virtual Filesystem Switch）。VFS对下为不同具体的文件系统抽象出一套通用的数据结构和操作函数，对上为用户态应用层程序屏蔽底层文件系统的细节而使用一套通用的接口进行交互。注意，本问题及的文件系统均指非纯内存的文件系统，如ext2、nfs等，而类似procfs、sysfs、tmpfs这种纯内存文件系统不在本文的讨论范围，也不是haystack论文优化的对象。&lt;/p&gt;
&lt;p&gt;VFS定义了四个基本对象，&lt;em&gt;superblock&lt;/em&gt;, &lt;em&gt;inode&lt;/em&gt;, &lt;em&gt;file&lt;/em&gt;, &lt;em&gt;dentry&lt;/em&gt;。其中：&lt;em&gt;superblock&lt;/em&gt; 用于描述&lt;strong&gt;文件系统&lt;/strong&gt;的元信息；&lt;em&gt;inode&lt;/em&gt; 用于描述&lt;strong&gt;文件&lt;/strong&gt;的元信息(如大小等）；&lt;em&gt;file&lt;/em&gt; 对象和具体进程关联，表示其&lt;strong&gt;打开&lt;/strong&gt;的一个文件和该进程关系（如打开方式、当前读写位置等）；&lt;em&gt;dentry&lt;/em&gt; 表示一个具体的目录项与实际文件的关系（指向某个_inode_）。这四者和进程间的关系如下图所示。
&lt;img src=&#34;https://xiaoqihai.oss-cn-shanghai.aliyuncs.com/img/20200130114445.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;具体地，对于每个应用程序而言，其直接操作的对象是文件句柄，也就是我们所说的&lt;code&gt;fd&lt;/code&gt;。&lt;code&gt;fd&lt;/code&gt;经&lt;code&gt;file descriptor table&lt;/code&gt;映射之后指向一个 &lt;em&gt;file&lt;/em&gt; 对象（多个fd可能指向同一个 &lt;em&gt;file&lt;/em&gt; 对象，比如&lt;code&gt;dup&lt;/code&gt;得到的fd），而一个 &lt;em&gt;file&lt;/em&gt; 对象指向一个VFS全局的 &lt;em&gt;dentry&lt;/em&gt; 对象（因为hardlink，多个 &lt;em&gt;file&lt;/em&gt; 对象可能指向同一个 &lt;em&gt;dentry&lt;/em&gt; 对象），而一个 &lt;em&gt;dentry&lt;/em&gt; 对象指向 &lt;em&gt;inode&lt;/em&gt; 对象（两者之间1对1关系），&lt;strong&gt;最终VFS通过 &lt;em&gt;inode&lt;/em&gt; 信息进行相应的文件操作&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;读写文件之前，需要获取 &lt;em&gt;inode&lt;/em&gt; 是理解haystack文章的关键点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;superblock&lt;/em&gt; 通常在文件系统挂载后就加载进内存，因此不会对单次文件访问带来性能影响。而 &lt;em&gt;file&lt;/em&gt;，&lt;em&gt;dentry&lt;/em&gt; 是由VFS构造的纯内存对象，不需要从磁盘加载，也可以认为没有性能影响。只有 &lt;em&gt;inode&lt;/em&gt; 需要通过具体的文件系统构造。通常情况下，VFS在获取文件对应的 &lt;em&gt;inode&lt;/em&gt; 时需要访问磁盘，文件系统驱动将从磁盘中拷贝（如ext2/3/4文件系统在磁盘上保存了inode信息，其它文件系统不一定保存了和内存中一样的_inode_结构体，但也需要访问磁盘构造VFS &lt;em&gt;inode&lt;/em&gt;）对应的 &lt;em&gt;inode&lt;/em&gt; 。那么是不是对于任何一个文件，在对其进行读写之前都需要从磁盘加载inode呢？答案是否定的，为了加速文件查找过程的效率，Linux维护了dcache(dentry cache)，将最近访问的dentry缓存在内存中。被缓存的dentry，其指向的inode也相应地被缓存在内存当中。然而对于海量文件，我们无法做到将所有的文件inode都缓存进内存之中。&lt;/p&gt;
&lt;h2 id=&#34;haystack-&#34;&gt;haystack 介绍&lt;/h2&gt;
&lt;p&gt;haystack主要为解决facebook海量图片的存储和访问而提出。图片文件具有体积小、一次写入后多次读取、几乎无修改的特点。对Facebook而言，图片的加载速度极其影响用户体验，再加上用户规模庞大，因此haystack必须做到高并发、低延迟。&lt;/p&gt;
&lt;p&gt;CDN(Content Delivery Network, 内容分发网络)在静态文件分发中扮演者举足轻重的角色，借用haystack论文中的图来描述常见的应用场景如下。&lt;br&gt;
&lt;img src=&#34;https://xiaoqihai.oss-cn-shanghai.aliyuncs.com/img/20200201172330.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;浏览器（用户）在请求静态资源时（这里主要关心图片，CDN也可以分发其它种类的文件)，web服务器返回CDN的资源地址。浏览器从CDN请求资源时，对于CDN，如果请求的资源在其缓存池中则直接返回，否则通过事先配置好的规则从指定的地点拉取资源并缓存，然后返回给用户。&lt;/p&gt;
&lt;p&gt;这里简单介绍下为什么通过CDN能做到高并发低延迟分发内容：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;基础设施。CDN厂商会搭建（购买、租用）很多基础网络设施，这些设施作为节点分布于全球各地。使用CDN来处理资源请求、在缓存命中的情况下能降低后端服务器的压力。&lt;/li&gt;
&lt;li&gt;就近访问。通过合理的调度、用户可以访问最近（最快）的物理节点来获取资源。&lt;/li&gt;
&lt;li&gt;专有线路。CDN厂商通常有自己的专线网络，这些专线网络相对公用网络带宽更大、网络阻塞的可能性更小。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;那么为什么CDN不能解决Facebook图片分发的问题？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;按照haystack论文中所述，CDN中只缓存了少部分访问频繁的文件，而低频的访问数量巨大，如果将所有的文件都缓存进CDN，虽然理论可行但是成本过高不符合实际。这个现象也叫做&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E9%95%BF%E5%B0%BE&#34;&gt;长尾效应&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;heading-1&#34;&gt;核心思想&lt;/h3&gt;
&lt;p&gt;在使用haystack之前，Facebook的图片系统使用如下图所示的架构，即若干图片服务器通过NFS的方式挂载了数个NAS存储。Facebook并没有公布其使用的NASA上具体的软件系统，不过从文章的描述来看，即使不能肯定这些NAS是Linux系统，也可以确定他们有类似上文描述的文件访问过程，即在读取文件内容之前需要先进行一次IO将对应的inode加载进内存之中。对于我们读者来说，这些NAS系统的细节我们并不需要关心，我们可以假设这些NAS就是一些Linux系统，这并不妨碍我们理解haystack的整体设计。
&lt;img src=&#34;https://xiaoqihai.oss-cn-shanghai.aliyuncs.com/img/20200201185805.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;io&#34;&gt;读取一张图片，需要多少次IO操作？&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;再简单回顾一下机械硬盘，磁盘寻址时间约10ms，顺序读取1MB数据约30ms。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;假设图片大小为64KB，为方便估算，我们假设这64KB的数据是连续的，也就是说只需要一次IO操作。虽然采用传统的基于block的文件系统时，这64KB的数据会分散在多个不通过的数据块中（因为数据不大，假设没有通过多级指针索引的数据块），虽然文件系统会为这64KB的数据发起多个不同的IO操作，但是因为他们是连续的块，最终经过编排调度之后也会合成一个IO操作。&lt;/p&gt;
&lt;p&gt;假设文件存放在多级目录中，在查找文件时，路径中的每一项都需要别解析成一个dentry对象，如果没有被dcache缓存住，那么也需要从磁盘加载对应的inode，也就是需要一次IO操作。同时，如果目录下的文件太多，以至于有些文件存放到目录的二级甚至三级数据索引中，并且由于目录项的查找是简单的遍历，那么需要更多的IO操作。通过调整目录项的大小或者使用更先进的一些文件系统（一些采用b-tree的文件系统），文件查找需要的IO操作可能会更小，但是我们可以认为对于一个文件至一次以上的磁盘操作用于读取其inode。&lt;/p&gt;
&lt;p&gt;我们知道哪怕仅仅是从磁盘读取一个扇区的数据，磁盘寻址时间也是一个不可忽略的开销。对于数据不大的图片而言，我们可以粗略认为有一半的额外开销都花在了读取文件的元信息之上。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;haystack的主要贡献也就是提出了一种将所有图片的元信息都缓存进内存，从而加速小文件读取的优化方法。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;heading-2&#34;&gt;架构&lt;/h3&gt;
&lt;p&gt;Haystack是一个分布式对象存储，主要包含三个模块：Directory、Cache和Storage。其中，Directory是一个元数据管理服务，Cache是数据缓存，而Storage是数据最终的存放地点。
&lt;img src=&#34;https://xiaoqihai.oss-cn-shanghai.aliyuncs.com/img/20200202165747.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;（由于工作原因没有时间写细节了，以后如果再搞存储会回来补充完整。）&lt;/p&gt;
&lt;h4 id=&#34;storage&#34;&gt;Storage&lt;/h4&gt;
&lt;h4 id=&#34;directory&#34;&gt;Directory&lt;/h4&gt;
&lt;h4 id=&#34;cache&#34;&gt;Cache&lt;/h4&gt;
&lt;h2 id=&#34;10haystack&#34;&gt;过去10年了，haystack还适用吗？&lt;/h2&gt;
&lt;h2 id=&#34;heading-3&#34;&gt;参考文献&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://www.usenix.org/legacy/event/osdi10/tech/full_papers/Beaver.pdf&#34;&gt;haystack&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;《Understanding the Linux kernel》&lt;/li&gt;
&lt;/ol&gt;</description>
      
    </item>
    
    <item>
      <title>自动重启电信光猫</title>
      <link>http://auntlei.com/post/misc/auto_reload_model/</link>
      <pubDate>Wed, 25 Dec 2019 22:47:46 +0800</pubDate>
      
      <guid>http://auntlei.com/post/misc/auto_reload_model/</guid>
      
        <description>&lt;h2 id=&#34;heading&#34;&gt;起因&lt;/h2&gt;
&lt;p&gt;家里的WiFi总是过一点时间就会很卡，让人不爽！&lt;/p&gt;
&lt;h3 id=&#34;heading-1&#34;&gt;网络布局&lt;/h3&gt;
&lt;p&gt;家里的网络布局和大多数普通家庭类似， 一个&lt;strong&gt;200M的电信宽带&lt;/strong&gt;接上一个路由器
&lt;img src=&#34;https://xiaoqihai.oss-cn-shanghai.aliyuncs.com/img/20191225233420.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;heading-2&#34;&gt;排障流程&lt;/h3&gt;
&lt;p&gt;从拓扑图看，设备接入互联网慢可能是两个组件有问题：电信光猫或者路由器。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;路由器问题？&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;对比台式电脑和移动设备之间的网速，并没有发现明显差距——都是龟速。加之路由器是新买不久的支持5G频率的千兆路由器，先大胆&lt;strong&gt;假设不是路由器故障&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;电信光猫&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;在台式电脑上&lt;/strong&gt;（这点很重要，保证了整个物理链路的物理带宽为千兆) 使用上海电信官网的测试界面进行测速，结果只有1MB左右，距离200Mb/8≈25MB 还有很大距离。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;初步可认定是电信光猫的问题，那么如何解决这个问题呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;方案1： 电信客服投诉，报修？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;根据过往经验，网速有时能恢复，工人上门维修不一定能复现。另外通过微信公众号的自检，电信认定为设备正常。 工人上门也就重启下，测试正常也就离开了。 &lt;strong&gt;这显然不能解决问题&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;方案2： 其它？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;比如换移动、联通？嗯，这是在搞笑。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;两个方案都不可行。但是在电信的测速界面看到一个非常有趣的提醒，大意是“现在测速结果偏慢，但是要在重启网关之后才能保证测速准确哦”。试着重启了光猫后，还真有效！
&lt;img src=&#34;https://xiaoqihai.oss-cn-shanghai.aliyuncs.com/img/20191225235959.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果我们假设重启光猫后网速能回归正常，那问题转变成如何自动重启光猫&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;heading-3&#34;&gt;通过路由器的剩余计算能力闲时自动重启光猫&lt;/h2&gt;
&lt;h3 id=&#34;heading-4&#34;&gt;如何自动重启光猫&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;家里的光猫可以通过web界面重启&lt;/strong&gt;， 那只需要抓包破解重启通信协议即可达成目标。&lt;/p&gt;
&lt;p&gt;本文中的光猫管理界面如下图所示：
&lt;img src=&#34;https://xiaoqihai.oss-cn-shanghai.aliyuncs.com/img/20191225224609.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;通过Chrome自带的HTTP抓包结果如下&lt;/p&gt;
&lt;p&gt;登录请求&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;HTTP GET http://192.168.1.1/login.cgi?username=useradmin&amp;amp;psd=&amp;lt;登录密码&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;登录后可发现web界面不断地发送post请求和光猫内的服务端进行数据和指令同步&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;HTTP POST http://192.168.1.1/gatewayManage.cmd?timeStamp=1577285343462&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://xiaoqihai.oss-cn-shanghai.aliyuncs.com/img/20191225225409.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;其中POST的body以表单形式发送，如：&lt;code&gt;jsonCfg=%7B%22RPCMethod%22%3A%22Post1%22%2C+&#39;ID&#39;%3A&#39;123&#39;%2C+%22Parameter%22%3A&#39;eyJDbWRUeXBlIjoiSEdfQ09NTUFORF9SRUJPT1QifQ%3D%3D&#39;%7D&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;URL decoded 之后为：&lt;code&gt;jsonCfg={&amp;quot;RPCMethod&amp;quot;:&amp;quot;Post1&amp;quot;, &#39;ID&#39;:&#39;123&#39;, &amp;quot;Parameter&amp;quot;:&#39;eyJDbWRUeXBlIjoiSEdfQ09NTUFORF9SRUJPT1QifQ==&#39;}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;通过观察多个请求，可以发现请求jsonCfg中的字段 &lt;code&gt;RPCMethod&lt;/code&gt;和&lt;code&gt;ID&lt;/code&gt;都是固定不变的， 而&lt;code&gt;Parameter&lt;/code&gt;是变化的。&lt;code&gt;Parameter&lt;/code&gt;实例是Base64编码的（因为有以&lt;code&gt;=&lt;/code&gt;结尾的，&lt;code&gt;=&lt;/code&gt;是base64编码的padding）。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;eyJDbWRUeXBlIjoiSEdfQ09NTUFORF9SRUJPT1QifQ==&lt;/code&gt; base64 decoded 之后为 &lt;code&gt;{&amp;quot;CmdType&amp;quot;:&amp;quot;HG_COMMAND_REBOOT&amp;quot;}&lt;/code&gt;&lt;strong&gt;从字面意思猜测，这就是重启路由器请求&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;URL中还有一个query参数为&lt;code&gt;timeStamp&lt;/code&gt;, 字面意思为时间戳。通过实验可知这个参数用来拒绝过期的请求（具体多长时间被视作过期没有详细测试）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;按照常识，HTTP header中应该有登录之后的session id，可是没有。&lt;/strong&gt; 这种简单的不需要多用户的管理系统，没有session也很正常，可以通过登录请求记录合法IP来保护敏感资源。
&lt;img src=&#34;https://xiaoqihai.oss-cn-shanghai.aliyuncs.com/img/20191225231258.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;于是我们可以构造如下命令来重启路由器：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 注意更新timeStamp&lt;/span&gt;
curl &lt;span class=&#34;s1&#34;&gt;&amp;#39;http://192.168.1.1/gatewayManage.cmd?timeStamp=1577286579429&amp;#39;&lt;/span&gt;  --data &lt;span class=&#34;s1&#34;&gt;$&amp;#39;jsonCfg=%7B%22RPCMethod%22%3A%22Post1%22%2C+\&amp;#39;ID\&amp;#39;%3A\&amp;#39;123\&amp;#39;%2C+%22Parameter%22%3A\&amp;#39;eyJDbWRUeXBlIjoiSEdfQ09NTUFORF9SRUJPT1QifQ%3D%3D\&amp;#39;%7D&amp;#39;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;执行后打印的http body如下，&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;{ &amp;#34;ID&amp;#34;: 123, &amp;#34;_Source&amp;#34;: 0, &amp;#34;Result&amp;#34;: 0, &amp;#34;return_Parameter&amp;#34;: &amp;#34;eyAiQ21kVHlwZSI6ICJIR19DT01NQU5EX1JFQk9PVCIsICJTZXF1ZW5jZUlkIjogbnVsbCwgIlN0YXR1cyI6ICIwIiB9&amp;#34; }
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;其中 &lt;code&gt;return_Parameter&lt;/code&gt; base64解码后为&lt;code&gt;{ &amp;quot;CmdType&amp;quot;: &amp;quot;HG_COMMAND_REBOOT&amp;quot;, &amp;quot;SequenceId&amp;quot;: null, &amp;quot;Status&amp;quot;: &amp;quot;0&amp;quot; }&lt;/code&gt;。 根据经验，一般0表示执行成功。&lt;/p&gt;
&lt;p&gt;执行后光猫的管理界面便不能打开，一小段时间之后才能再次反问。通过查看光猫的运行状态（运行时间），证实了刚才的重启是有效的！
&lt;img src=&#34;https://xiaoqihai.oss-cn-shanghai.aliyuncs.com/img/20191226002901.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;heading-5&#34;&gt;如何通过路由器自动定时重启光猫？&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;路由器&lt;/strong&gt;（注意不是光猫）可以ssh登录, 有一个精简的linux系统，有一整套的busybox。路由器也刷了梅林固件，当然也可以安装其他软件，甚至Python。解决方案多种多样，比如下面的shell 脚本。&lt;a href=&#34;https://www.shellscript.sh/&#34;&gt;shell 脚本教程&lt;/a&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#!/bin/sh
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;while&lt;/span&gt; : &lt;span class=&#34;c1&#34;&gt;# 死循环&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;do&lt;/span&gt;
	&lt;span class=&#34;nb&#34;&gt;echo&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;Date: &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;date&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;
	&lt;span class=&#34;nv&#34;&gt;hour&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;date +%H&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;$hour&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;4&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;then&lt;/span&gt;
		&lt;span class=&#34;nb&#34;&gt;echo&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;reboot modem&amp;#34;&lt;/span&gt;
		&lt;span class=&#34;c1&#34;&gt;# login&lt;/span&gt;
		curl &lt;span class=&#34;s2&#34;&gt;&amp;#34;http://192.168.1.1/login.cgi?username=useradmin&amp;amp;psd=密码&amp;#34;&lt;/span&gt;
		&lt;span class=&#34;c1&#34;&gt;# reboot&lt;/span&gt;
		curl &lt;span class=&#34;s1&#34;&gt;&amp;#39;http://192.168.1.1/gatewayManage.cmd?timeStamp=2555758215000&amp;#39;&lt;/span&gt;  --data &lt;span class=&#34;s1&#34;&gt;$&amp;#39;jsonCfg=%7B%22RPCMethod%22%3A%22Post1%22%2C+\&amp;#39;ID\&amp;#39;%3A\&amp;#39;123\&amp;#39;%2C+%22Parameter%22%3A\&amp;#39;eyJDbWRUeXBlIjoiSEdfQ09NTUFORF9SRUJPT1QifQ%3D%3D\&amp;#39;%7D&amp;#39;&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;fi&lt;/span&gt;
	sleep &lt;span class=&#34;m&#34;&gt;3600&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;# 1小时唤醒一次&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;done&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;说明：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;时间戳2555758215000 是2050年的一个时间。实验可知时间戳判断逻辑过于简单：当前时间-timestamp &amp;gt; 阈值 就认为过期。我们传一个比当前时间更后的时间是一种取巧的hack方式，当然也可以通过 &lt;code&gt;date +%s&lt;/code&gt;来获取时间，但是没有必要。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;脚本每小时唤醒一次，在凌晨4点触发重启。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;脚本需要放到一个&lt;strong&gt;非临时存储&lt;/strong&gt;，注意不要保存在路由器的tmpfs&lt;/p&gt;
&lt;blockquote&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;admin@RT-AC68P:/tmp/home/root# ls -l /root
lrwxrwxrwx    1 admin    root            13 Sep 21 14:13 /root -&amp;gt; tmp/home/root
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用 &lt;code&gt;nohup&lt;/code&gt; 来保证脚本持续运行。 当然也可以研究下你的路由器支持哪种开机自动运行的能力(比如&lt;code&gt;/etc/init.d&lt;/code&gt;)&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;当然更方便的是利用梅林固件的服务脚本和cru定时任务管理器。&lt;/p&gt;
&lt;h4 id=&#34;cru&#34;&gt;使用梅林固件的定时任务软件&lt;code&gt;cru&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;首先我们需要打开jffs分区。这是个非临时存储，换言之就是在路由器重启之后数据不会丢失。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://xiaoqihai.oss-cn-shanghai.aliyuncs.com/img/20191227215121.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;将脚本脚本放到指定目录&lt;code&gt;/jffs/scripts/&lt;/code&gt;, 并且添加可执行权限。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#!/bin/sh
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;
&lt;span class=&#34;nb&#34;&gt;echo&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;date&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt; &amp;gt; /tmp/modem_reboot.log
curl &lt;span class=&#34;s2&#34;&gt;&amp;#34;http://192.168.1.1/login.cgi?username=useradmin&amp;amp;psd=密码&amp;#34;&lt;/span&gt;
curl &lt;span class=&#34;s1&#34;&gt;&amp;#39;http://192.168.1.1/gatewayManage.cmd?timeStamp=2555758215000&amp;#39;&lt;/span&gt;  --data &lt;span class=&#34;s1&#34;&gt;$&amp;#39;jsonCfg=%7B%22RPCMethod%22%3A%22Post1%22%2C+\&amp;#39;ID\&amp;#39;%3A\&amp;#39;123\&amp;#39;%2C+%22Parameter%22%3A\&amp;#39;eyJDbWRUeXBlIjoiSEdfQ09NTUFORF9SRUJPT1QifQ%3D%3D\&amp;#39;%7D&amp;#39;&lt;/span&gt; &amp;gt;&amp;gt; /tmp/modem_reboot.log
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;对脚本进行了进一步的完善，其中3行，将&lt;strong&gt;最近一次&lt;/strong&gt;执行时间写进文件日志文件&lt;code&gt;/tmp/modem_reboot.log&lt;/code&gt;, 最后一行将重启结果也写进了日志。 &lt;strong&gt;程序猿要以数据说话，不能靠感觉&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;脚本可以选择不同的启动时间，由于是重启光猫，可以选择了&lt;a href=&#34;https://github.com/RMerl/asuswrt-merlin/wiki/User-scripts&#34;&gt;post-mount，即jffs刚被挂载好便触发
&lt;/a&gt;。 将下面的代码添加至&lt;code&gt;/jffs/scripts/post-mount&lt;/code&gt;文件中&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# automatically reboot my model to 04:00 am every day&lt;/span&gt;
cru a rebootmodem &lt;span class=&#34;s2&#34;&gt;&amp;#34;0 4 * * * /jffs/scripts/auto_reboot_modem.sh&amp;#34;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;为了验证&lt;code&gt;post-mount&lt;/code&gt; 是否会触发，可以重启&lt;strong&gt;路由器&lt;/strong&gt;（not 光猫）， 然后&lt;code&gt;cru l&lt;/code&gt;查看任务&#39;rebootmodem&amp;rsquo; 是否存在。如果你能看到如下内容，说明我们的脚本配置成功，cron job已经被添加。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;admin@RT-AC68P:/tmp/home/root# cru l
&lt;span class=&#34;m&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;4&lt;/span&gt; * * * /jffs/scripts/auto_reboot_modem.sh &lt;span class=&#34;c1&#34;&gt;#rebootmodem#&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;strong&gt;最后附上次日清晨的日志文件内容，证明整个方案是可靠的&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;admin@RT-AC68P:/tmp/home/root# cat /tmp/modem_reboot.log
Sat Dec 28 04:00:01 GMT 2019
{ &amp;#34;ID&amp;#34;: 123, &amp;#34;_Source&amp;#34;: 0, &amp;#34;Result&amp;#34;: 0, &amp;#34;return_Parameter&amp;#34;: &amp;#34;eyAiQ21kVHlwZSI6ICJIR19DT01NQU5EX1JFQk9PVCIsICJTZXF1ZW5jZUlkIjogbnVsbCwgIlN0YXR1cyI6ICIwIiB9&amp;#34; }
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;https://xiaoqihai.oss-cn-shanghai.aliyuncs.com/img/20191228102807.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>golang UDP 服务端实现</title>
      <link>http://auntlei.com/post/net/udp/</link>
      <pubDate>Fri, 20 Dec 2019 13:26:45 +0800</pubDate>
      
      <guid>http://auntlei.com/post/net/udp/</guid>
      
        <description>&lt;h2 id=&#34;heading&#34;&gt;协议特点&lt;/h2&gt;
&lt;p&gt;简单地对IP协议进行了一层包裹，添加了源、目的地端口，从而支持了多路复用、多路分解. 协议本身没有流控测流和拥塞控制策略。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://xiaoqihai.oss-cn-shanghai.aliyuncs.com/img/udp-header.png&#34; alt=&#34;UDP 包头&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;heading-1&#34;&gt;好处&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;首部小， UDP 8字节， TCP20字节&lt;/li&gt;
&lt;li&gt;应用层能更加精确地控制发送数据的时间&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;heading-2&#34;&gt;缺点，使用注意事项&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;不可靠。协议本身不保证应用层的数据，一定能完全达到目的地。但是每个UDP 包裹本身是数据是不会出错（UDP本身有校验和）&lt;/li&gt;
&lt;li&gt;在网络上可能被很多节点的防火墙禁用掉&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;udp&#34;&gt;常见的使用UDP的应用层协议&lt;/h3&gt;
&lt;p&gt;DNS&lt;/p&gt;
&lt;h2 id=&#34;golang-udp-server&#34;&gt;golang 实现简单的UDP server&lt;/h2&gt;
&lt;p&gt;可以自己手动定义协议，但是考虑到易用性和以后升级的需要，可以简单得使用protobuf 来定义以及序列化。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-golang&#34; data-lang=&#34;golang&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Serve &amp;#34;监听&amp;#34;一个UDP端口，如&amp;#34;0.0.0.0:9527&amp;#34;
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;s&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;SimpleUDPServer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Serve&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;address&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;error&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;net&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;ListenPacket&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;udp&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;address&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;conn&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;c1&#34;&gt;// 如果会使用到公网，UDP的包尽量不要太大, 500 字节内为宜
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;c1&#34;&gt;// https://stackoverflow.com/questions/1098897/what-is-the-largest-safe-udp-packet-size-on-the-internet
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;c1&#34;&gt;// 这里的maxBufferSize 应该 &amp;gt; 你设计的协议中最大包的大小
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;		&lt;span class=&#34;nx&#34;&gt;buffer&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;make&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;byte&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;maxBufferSize&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;addr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;conn&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;ReadFrom&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;buffer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
			&lt;span class=&#34;nx&#34;&gt;logs&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Error&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;failed to receive udp packet: %v&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
			&lt;span class=&#34;k&#34;&gt;continue&lt;/span&gt;
		&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

        &lt;span class=&#34;c1&#34;&gt;// 新启一个goroutine 来处理请求。主goroutine 不处理除了接受包之外的其它任何
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;		&lt;span class=&#34;k&#34;&gt;go&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;handleRequest&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;buffer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;addr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;s&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;SimpleUDPServer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;handleRequest&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;byte&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;addr&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;net&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Addr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;</description>
      
    </item>
    
  </channel>
</rss>
